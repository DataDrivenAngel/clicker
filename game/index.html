<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Cookie Clicker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>

    <!-- Gear Icon -->
    <button id="settingsBtn" class="settings-icon">‚öôÔ∏è</button>

    <div id="game-container">
        <!-- Left Zone -->
        <div class="click-zone">
            <div class="score-container">
                <span id="score">0</span>
                <div class="score-label">Cookies</div>
                <div id="cps-display">per second: 0.0</div>

                <!-- Heat Meter -->
                <div id="heat-container" class="heat-container">
                    <div id="heat-bar" class="heat-bar"></div>
                    <div class="heat-text">MAX HEAT! (x2 Clicks)</div>
                </div>

                <!-- Max Clicks Per Second Display -->
                <div id="max-cps-display" class="max-cps-display" style="display: none;">
                    Max: <span id="max-cps-value">0</span> clicks/sec
                </div>
            </div>

            <button id="cookieBtn" class="cookie-btn">
                <div class="cookie-visual" id="cookieVisual">
                    <!-- Chips generated by JS -->
                </div>
            </button>
        </div>

        <!-- Right Zone -->
        <div class="upgrades-panel">
            <div class="panel-header">
                <span>Store</span>
                <div class="store-tabs">
                    <button id="tab-structures" class="tab-btn active">Structures</button>
                    <button id="tab-tech" class="tab-btn">Tech</button>
                    <button id="tab-meta" class="tab-btn">Meta</button>
                    <button id="statsBtn" class="reset-btn"
                        style="display: none; background: rgba(147, 51, 234, 0.1); color: #a855f7; border-color: rgba(147, 51, 234, 0.2); margin-left: 0.5rem;">Stats</button>
                </div>
            </div>
            <div id="upgrades-list">
                <!-- Upgrades injected by JS -->
            </div>
            <div id="tech-list" style="display: none; overflow-y: auto; flex-grow: 1; padding-right: 0.5rem;">
                <!-- Tech injected by JS -->
            </div>
            <div id="meta-list" style="display: none; overflow-y: auto; flex-grow: 1; padding-right: 0.5rem;">
                <!-- Meta Upgrades injected by JS -->
            </div>
        </div>


    </div>

    <!-- Tooltip Element -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Stats Modal -->
    <div id="statsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span>Statistics</span>
                <button class="close-modal" id="closeStats">√ó</button>
            </div>
            <div id="statsContent">
                <div id="statsText">
                    <!-- Stats Text injected by JS -->
                </div>
                <div id="statsChartContainer"
                    style="display: none; margin-top: 2rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <canvas id="statsChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span>Settings</span>
                <button class="close-modal" id="closeSettings">√ó</button>
            </div>
            <div class="settings-content">
                <p style="color: var(--text-muted); margin-bottom: 2rem;">Manage your game data and preferences.</p>

                <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                    <button id="exportBtn" class="reset-btn"
                        style="flex: 1; background: rgba(59, 130, 246, 0.1); color: #3b82f6; border-color: rgba(59, 130, 246, 0.2);">
                        üíæ Export Save
                    </button>
                    <button id="importBtn" class="reset-btn"
                        style="flex: 1; background: rgba(16, 185, 129, 0.1); color: #10b981; border-color: rgba(16, 185, 129, 0.2);">
                        üìÇ Import Save
                    </button>
                </div>
                <input type="file" id="importFile" style="display: none" accept=".txt,.json">

                <button id="resetBtn" class="reset-btn" style="width: 100%; padding: 1rem; font-size: 1rem;">
                    ‚ö†Ô∏è Wipe Save Data
                </button>
                <p style="font-size: 0.8rem; color: rgba(255,255,255,0.3); margin-top: 2rem; text-align: center;">
                    Cosmic Clicker v1.2
                </p>
            </div>
        </div>
    </div>

    <script>
        // Game State
        const defaultState = {
            score: 0,
            totalClicks: 0,
            startTime: Date.now(),
            upgrades: {
                cursor: { id: 'cursor', name: 'Cursor', baseCost: 15, cps: 0.1, count: 0, icon: 'üëÜ' },
                grandma: { id: 'grandma', name: 'Grandma', baseCost: 100, cps: 1, count: 0, icon: 'üëµ' },
                farm: { id: 'farm', name: 'Cookie Farm', baseCost: 1100, cps: 8, count: 0, icon: 'üöú' },
                mine: { id: 'mine', name: 'Mine', baseCost: 12000, cps: 47, count: 0, icon: '‚õèÔ∏è' },
                factory: { id: 'factory', name: 'Factory', baseCost: 130000, cps: 260, count: 0, icon: 'üè≠' },
                bank: { id: 'bank', name: 'Bank', baseCost: 1400000, cps: 1400, count: 0, icon: 'üè¶' },
                temple: { id: 'temple', name: 'Temple', baseCost: 20000000, cps: 7800, count: 0, icon: 'üèõÔ∏è' },
                wizardTower: { id: 'wizardTower', name: 'Wizard Tower', baseCost: 330000000, cps: 44000, count: 0, icon: 'üßô‚Äç‚ôÇÔ∏è' },
                shipment: { id: 'shipment', name: 'Shipment', baseCost: 5100000000, cps: 260000, count: 0, icon: 'üöÄ' },
                alchemyLab: { id: 'alchemyLab', name: 'Alchemy Lab', baseCost: 75000000000, cps: 1600000, count: 0, icon: '‚öóÔ∏è' },
                portal: { id: 'portal', name: 'Portal', baseCost: 1000000000000, cps: 10000000, count: 0, icon: 'üåÄ' },
                timeMachine: { id: 'timeMachine', name: 'Time Machine', baseCost: 14000000000000, cps: 65000000, count: 0, icon: '‚è≥' }
            },
            tech: {
                // Format: id: { name, cost, desc, trigger: { building, count }, effect: { type: 'mult', target, value }, purchased: false }
                reinforcedIndex: { id: 'reinforcedIndex', name: 'Reinforced Index Finger', cost: 100, desc: 'Cursor clicks are twice as efficient.', trigger: { building: 'cursor', count: 10 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üëÜ' },
                carpalTunnel: { id: 'carpalTunnel', name: 'Carpal Tunnel Prevention', cost: 500, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 25 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üß§' },
                ambidextrous: { id: 'ambidextrous', name: 'Ambidextrous', cost: 10000, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 50 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: '‚úåÔ∏è' },

                lubricatedDentures: { id: 'lubricatedDentures', name: 'Lubricated Dentures', cost: 1000, desc: 'Grandmas are twice as efficient.', trigger: { building: 'grandma', count: 10 }, effect: { type: 'mult', target: 'grandma', value: 2 }, purchased: false, icon: 'ü¶∑' },
                pruneJuice: { id: 'pruneJuice', name: 'Prune Juice', cost: 5000, desc: 'Grandmas are twice as efficient.', trigger: { building: 'grandma', count: 25 }, effect: { type: 'mult', target: 'grandma', value: 2 }, purchased: false, icon: 'ü•§' },
                doubleRollingPin: { id: 'doubleRollingPin', name: 'Double Rolling Pin', cost: 50000, desc: 'Grandmas are twice as efficient.', trigger: { building: 'grandma', count: 50 }, effect: { type: 'mult', target: 'grandma', value: 2 }, purchased: false, icon: 'ü•ñ' },

                cheapHoes: { id: 'cheapHoes', name: 'Cheap Hoes', cost: 11000, desc: 'Farms are twice as efficient.', trigger: { building: 'farm', count: 10 }, effect: { type: 'mult', target: 'farm', value: 2 }, purchased: false, icon: 'ÔøΩ' },
                fertilizer: { id: 'fertilizer', name: 'Fertilizer', cost: 55000, desc: 'Farms are twice as efficient.', trigger: { building: 'farm', count: 25 }, effect: { type: 'mult', target: 'farm', value: 2 }, purchased: false, icon: 'üí©' },

                sturdyPicks: { id: 'sturdyPicks', name: 'Sturdy Picks', cost: 120000, desc: 'Mines are twice as efficient.', trigger: { building: 'mine', count: 10 }, effect: { type: 'mult', target: 'mine', value: 2 }, purchased: false, icon: '‚õèÔ∏è' },
                boreDrill: { id: 'boreDrill', name: 'Bore Drill', cost: 600000, desc: 'Mines are twice as efficient.', trigger: { building: 'mine', count: 25 }, effect: { type: 'mult', target: 'mine', value: 2 }, purchased: false, icon: 'üî©' }
            },
            metaUpgrades: {
                analytics: {
                    id: 'analytics',
                    name: 'Analytics',
                    count: 0,
                    icon: 'üìä',
                    levels: [
                        { cost: 50, desc: 'Unlocks statistics (History: 0)' },
                        { cost: 100, desc: 'Unlocks Chart: Cookies (History: 100)' },
                        { cost: 1000, desc: 'Unlocks Chart: CPS (History: 200)' },
                        { cost: 2000, desc: 'Shows Efficiency (CPS/Cost) (History: 400)' },
                        { cost: 5000, desc: 'Shows Time-to-Wait (History: 800)' },
                        { cost: 7500, desc: 'Unlocks Chart: Upgrades (History: 1200)' },
                        { cost: 15000, desc: 'Extended History (History: 3000)' }
                    ]
                },
                autoBuyer: {
                    id: 'autoBuyer',
                    name: 'Auto Buyer',
                    count: 0,
                    icon: 'ü§ñ',
                    levels: [
                        { cost: 10000, desc: 'Auto-buys cheapest every 5s' },
                        { cost: 100000, desc: 'Auto-buys cheapest every 1s' },
                        { cost: 500000, desc: 'Auto-buys cheapest every 0.5s' },
                        { cost: 1000000, desc: 'Auto-buys most efficient every 1s' }
                    ]
                },
                clickFrenzy: {
                    id: 'clickFrenzy',
                    name: 'Click Frenzy',
                    count: 0,
                    icon: 'üî•',
                    levels: [
                        { cost: 100, desc: 'Unlocks Heat Meter (x2 Clicks at Max)' },
                        { cost: 250, desc: 'Heat decays 50% slower, +1 cookie per click above 50% heat' },
                        { cost: 500, desc: 'x5 Click Power at Max Heat' },
                        { cost: 2500, desc: 'Quick Ignition: +15 heat per click' },
                        { cost: 10000, desc: 'Inferno Mode: +10% CPS at Max Heat' },
                        { cost: 50000, desc: 'Chain Reaction: Clicks sustain heat at max' },
                        { cost: 250000, desc: 'Blazing Strikes: +5 cookies per click at Max Heat' },
                        { cost: 1000000, desc: 'Momentum: CPS multiplier grows with clicking speed at max heat' }
                    ]
                },
                timeWarp: {
                    id: 'timeWarp',
                    name: 'Time Warp',
                    count: 0,
                    icon: '‚è≥',
                    levels: [
                        { cost: 1000, desc: '10% Offline Earnings (Max 1hr)' },
                        { cost: 5000, desc: '25% Offline Earnings (Max 4hr)' },
                        { cost: 25000, desc: '50% Offline Earnings (Max 24hr)' }
                    ]
                },
                luckyClover: {
                    id: 'luckyClover',
                    name: 'Lucky Clover',
                    count: 0,
                    icon: 'üçÄ',
                    levels: [
                        { cost: 5000, desc: 'Golden Cookies spawn (15 minutes of Cookies Per Second reward)' },
                        { cost: 25000, desc: 'Double Reward (30m CPS)' },
                        { cost: 100000, desc: 'Double Spawn Rate' }
                    ]
                },
                goldenNet: {
                    id: 'goldenNet',
                    name: 'Golden Net',
                    count: 0,
                    icon: 'üï∏Ô∏è',
                    levels: [
                        { cost: 100000, desc: 'Auto-clicks Golden Cookies (5s delay)' },
                        { cost: 500000, desc: 'Auto-clicks Golden Cookies (2s delay)' },
                        { cost: 2500000, desc: 'Instant Auto-click (0.1s delay)' }
                    ]
                }
            },
            stats: {
                totalCookies: 0,
                totalClicks: 0,
                startTime: Date.now(),
                lastSaveTime: Date.now(),
                history: [] // { timestamp, cookies, cps, upgrades }
            },
            settings: {
                autoBuyerMode: 'off' // 'off', 'cheapest', 'efficient'
            }
        };

        // Fix: Deep copy defaultState to avoid mutation
        let state = JSON.parse(JSON.stringify(defaultState));
        // Ensure settings exist if loading from old save
        if (!state.settings) state.settings = { autoBuyerMode: 'off' };
        // Ensure tech exists if loading from old save
        if (!state.tech) state.tech = JSON.parse(JSON.stringify(defaultState.tech));
        // Ensure new buildings exist
        Object.keys(defaultState.upgrades).forEach(key => {
            if (!state.upgrades[key]) state.upgrades[key] = { ...defaultState.upgrades[key] };
        });
        let heat = 0;
        let heatDecayRate = 0.5;
        let isResetting = false; // Flag to prevent save on reset

        // Click tracking for CPS display
        let clickTimestamps = []; // Array of click timestamps
        let maxClicksPerSecond = 0; // Max clicks per second in last 60s

        // Momentum tracking (Level 8)
        let momentumMultiplier = 1.0; // CPS multiplier from momentum
        let timeAtMaxHeat = 0; // Time spent at max heat in seconds

        // DOM Elements
        const scoreEl = document.getElementById('score');
        const cpsEl = document.getElementById('cps-display');
        const cookieBtn = document.getElementById('cookieBtn');
        const upgradesList = document.getElementById('upgrades-list');
        const techList = document.getElementById('tech-list');
        const metaList = document.getElementById('meta-list');
        const tabStructures = document.getElementById('tab-structures');
        const tabTech = document.getElementById('tab-tech');
        const tabMeta = document.getElementById('tab-meta');
        const resetBtn = document.getElementById('resetBtn');
        const statsBtn = document.getElementById('statsBtn');
        const cookieVisual = document.getElementById('cookieVisual');
        const tooltip = document.getElementById('tooltip');
        const statsModal = document.getElementById('statsModal');
        const closeStats = document.getElementById('closeStats');
        const statsContent = document.getElementById('statsContent');
        const statsText = document.getElementById('statsText');
        const statsChartContainer = document.getElementById('statsChartContainer');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettings = document.getElementById('closeSettings');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const importFile = document.getElementById('importFile');
        const heatContainer = document.getElementById('heat-container');
        const heatBar = document.getElementById('heat-bar');
        const heatText = document.querySelector('.heat-text');
        const maxCpsDisplay = document.getElementById('max-cps-display');
        const maxCpsValue = document.getElementById('max-cps-value');

        // Helper: Format Numbers
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
            // if (num >= 1000) return (num / 1000).toFixed(1) + 'k'; // User requested no 4-digit truncation
            return Math.floor(num).toLocaleString(); // Add commas for readability
        }

        // Helper: Format CPS (allows decimals)
        function formatCPS(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
            return num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 1 });
        }

        // Helper: Calculate Cost
        function getCost(upgradeId) {
            const u = state.upgrades[upgradeId];
            return Math.floor(u.baseCost * Math.pow(1.15, u.count));
        }

        // Helper: Calculate Total CPS
        function getCPS() {
            let cps = 0;

            // Refined CPS Calculation
            Object.values(state.upgrades).forEach(u => {
                let buildingCPS = u.cps * u.count;

                // Apply Tech Multipliers for this building
                let multiplier = 1;
                Object.values(state.tech).forEach(t => {
                    if (t.purchased && t.effect.type === 'mult' && t.effect.target === u.id) {
                        multiplier *= t.effect.value;
                    }
                });

                cps += buildingCPS * multiplier;
            });

            // Level 5: Inferno Mode - +10% CPS at Max Heat
            if (state.metaUpgrades.clickFrenzy.count >= 5 && heat >= 100) {
                cps *= 1.10;
            }

            // Level 8: Momentum - Apply momentum multiplier
            if (state.metaUpgrades.clickFrenzy.count >= 8) {
                cps *= momentumMultiplier;
            }

            return cps;
        }

        // Initialization
        function init() {
            loadGame();
            generateChips();
            createUpgradesList(); // Create DOM once
            createTechList(); // Create DOM once for tech
            createMetaList();
            updateUI(); // Initial UI update
            requestAnimationFrame(gameLoop);

            // Auto-save every 30 seconds
            setInterval(saveGame, 30000);

            // Auto-Buyer Loop (1s tick, logic handles throttling)
            setInterval(runAutoBuyer, 1000);

            // Heat Decay Loop (100ms)
            setInterval(updateHeat, 100);

            // Golden Cookie Loop (Check every 1s)
            setInterval(trySpawnGoldenCookie, 1000);

            // Check Offline Earnings
            checkOfflineEarnings();

            // Analytics Data Recording (Every 5s)
            setInterval(recordAnalyticsData, 5000);

            // Fix: Save on exit
            window.addEventListener('beforeunload', saveGame);

            // Event Listeners
            closeStats.addEventListener('click', closeStatsModal);
            statsBtn.addEventListener('click', showStats);
            statsModal.addEventListener('click', (e) => {
                if (e.target === statsModal) closeStatsModal();
            });

            // Tabs
            // Tabs
            tabStructures.addEventListener('click', () => switchTab('structures'));
            tabTech.addEventListener('click', () => switchTab('tech'));
            tabMeta.addEventListener('click', () => switchTab('meta'));

            // Settings
            settingsBtn.addEventListener('click', () => settingsModal.classList.add('active'));
            closeSettings.addEventListener('click', () => settingsModal.classList.remove('active'));
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) settingsModal.classList.remove('active');
            });

            resetBtn.addEventListener('click', () => {
                if (confirm("Are you sure you want to wipe your save?")) {
                    isResetting = true; // Prevent other saves

                    // Preserve lifetime stats before reset
                    const lifetimeStats = {
                        totalCookies: state.stats.totalCookies,
                        totalClicks: state.stats.totalClicks,
                        startTime: state.stats.startTime
                    };

                    // Explicitly overwrite with default state
                    state = JSON.parse(JSON.stringify(defaultState));
                    // Explicitly reset upgrade counts
                    Object.keys(state.upgrades).forEach(key => {
                        state.upgrades[key].count = 0;
                    });
                    // Explicitly reset meta upgrades
                    if (state.metaUpgrades) {
                        Object.keys(state.metaUpgrades).forEach(key => {
                            state.metaUpgrades[key].count = 0;
                        });
                    }
                    // Explicitly reset tech
                    if (state.tech) {
                        Object.keys(state.tech).forEach(key => {
                            state.tech[key].purchased = false;
                        });
                    }
                    // Reset stats but preserve lifetime stats
                    state.stats = {
                        totalCookies: lifetimeStats.totalCookies,
                        totalClicks: lifetimeStats.totalClicks,
                        startTime: lifetimeStats.startTime,
                        lastSaveTime: Date.now(),
                        history: []
                    };
                    // Save the empty state immediately
                    localStorage.setItem('cosmicClickerSave', JSON.stringify(state));
                    // Force reload
                    location.reload();
                }
            });

            // Export Save
            exportBtn.addEventListener('click', () => {
                const data = JSON.stringify(state);
                const blob = new Blob([data], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cosmic_clicker_save_${Date.now()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            });

            // Import Save
            importBtn.addEventListener('click', () => importFile.click());

            importFile.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        // Basic validation
                        if (data.score !== undefined && data.upgrades) {
                            isResetting = true; // Prevent overwrite during reload
                            localStorage.setItem('cosmicClickerSave', JSON.stringify(data));
                            location.reload();
                        } else {
                            alert("Invalid save file!");
                        }
                    } catch (err) {
                        alert("Error reading save file!");
                        console.error(err);
                    }
                };
                reader.readAsText(file);
            });
        }

        // Generate visual chips on the cookie
        function generateChips() {
            for (let i = 0; i < 8; i++) {
                const chip = document.createElement('div');
                chip.classList.add('chip');
                const size = Math.random() * 20 + 15;
                chip.style.width = `${size}px`;
                chip.style.height = `${size}px`;
                chip.style.top = `${Math.random() * 70 + 10}%`;
                chip.style.left = `${Math.random() * 70 + 10}%`;
                chip.style.transform = `rotate(${Math.random() * 360}deg)`;
                cookieVisual.appendChild(chip);
            }
        }

        // Fix: Create Upgrades List (Run once)
        function createUpgradesList() {
            upgradesList.innerHTML = '';
            Object.values(state.upgrades).forEach(u => {
                const item = document.createElement('div');
                item.className = 'upgrade-item';
                item.id = `upgrade-${u.id}`;
                item.onclick = () => buyUpgrade(u.id);

                // Tooltip Events
                item.onmouseenter = (e) => showTooltip(u.id, e.clientX, e.clientY);
                item.onmousemove = (e) => moveTooltip(e.clientX, e.clientY);
                item.onmouseleave = hideTooltip;

                item.innerHTML = `
                    <div class="upgrade-icon">${u.icon}</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">${u.name}</div>
                        <div class="upgrade-cost">üç™ ${formatNumber(getCost(u.id))}</div>
                    </div>
                    <div class="upgrade-count">${u.count}</div>
                `;
                upgradesList.appendChild(item);
            });
        }

        // Tabs Logic
        // Tabs Logic
        function switchTab(tab) {
            // Reset all
            upgradesList.style.display = 'none';
            techList.style.display = 'none';
            metaList.style.display = 'none';
            tabStructures.classList.remove('active');
            tabTech.classList.remove('active');
            tabMeta.classList.remove('active');

            if (tab === 'structures') {
                upgradesList.style.display = 'block';
                tabStructures.classList.add('active');
            } else if (tab === 'tech') {
                techList.style.display = 'block';
                tabTech.classList.add('active');
            } else if (tab === 'meta') {
                metaList.style.display = 'block';
                tabMeta.classList.add('active');
            }
        }

        // Tech Logic
        function createTechList() {
            techList.innerHTML = '';
            Object.values(state.tech).forEach(t => {
                const item = document.createElement('div');
                item.className = 'tech-item';
                item.id = `tech-${t.id}`;
                item.onclick = () => buyTech(t.id);

                // Initially hidden until unlocked
                item.style.display = 'none';

                item.innerHTML = `
                    <div class="tech-icon">${t.icon}</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">${t.name}</div>
                        <div class="upgrade-cost">üç™ ${formatNumber(t.cost)}</div>
                    </div>
                `;

                // Tooltip
                item.onmouseenter = (e) => {
                    tooltip.innerHTML = `
                        <div class="tooltip-header">${t.name}</div>
                        <div class="tooltip-stat">${t.desc}</div>
                        <div class="tooltip-stat">Cost: <span>üç™ ${formatNumber(t.cost)}</span></div>
                    `;
                    tooltip.style.display = 'block';
                    moveTooltip(e.clientX, e.clientY);
                };
                item.onmousemove = (e) => moveTooltip(e.clientX, e.clientY);
                item.onmouseleave = hideTooltip;

                techList.appendChild(item);
            });
        }

        function updateTechVisuals() {
            Object.values(state.tech).forEach(t => {
                const item = document.getElementById(`tech-${t.id}`);
                if (!item) return;

                // Check Trigger
                const triggerBuilding = state.upgrades[t.trigger.building];
                const isUnlocked = triggerBuilding && triggerBuilding.count >= t.trigger.count;

                if (t.purchased) {
                    item.classList.add('purchased'); // CSS hides it
                } else if (isUnlocked) {
                    item.style.display = 'flex';

                    if (state.score >= t.cost) {
                        item.classList.remove('disabled');
                    } else {
                        item.classList.add('disabled');
                    }
                } else {
                    item.style.display = 'none';
                }
            });
        }

        function buyTech(techId) {
            const t = state.tech[techId];
            if (t.purchased) return;
            if (state.score >= t.cost) {
                state.score -= t.cost;
                t.purchased = true;
                updateTechVisuals();
                updateUI();
                saveGame();
            }
        }

        // Create Meta List
        function createMetaList() {
            metaList.innerHTML = '';
            Object.values(state.metaUpgrades).forEach(u => {
                const item = document.createElement('div');
                item.className = 'upgrade-item';
                item.id = `meta-${u.id}`;
                item.onclick = () => buyMetaUpgrade(u.id);

                // Determine current level info
                const currentLevel = u.count;
                const nextLevel = u.levels[currentLevel];
                const isMaxed = currentLevel >= u.levels.length;

                const costText = isMaxed ? "Maxed" : `üç™ ${formatNumber(nextLevel.cost)}`;
                const descText = isMaxed ? "Max Level Reached" : nextLevel.desc;
                const levelText = isMaxed ? `Lvl ${currentLevel}` : `Lvl ${currentLevel} ‚Üí ${currentLevel + 1}`;

                let toggleHtml = '';
                if (u.id === 'autoBuyer' && currentLevel > 0) {
                    const mode = state.settings.autoBuyerMode || 'off';
                    let modeColor = '#ef4444'; // Red for OFF
                    if (mode === 'cheapest') modeColor = '#22c55e'; // Green for CHEAPEST
                    if (mode === 'efficient') modeColor = '#3b82f6'; // Blue for EFFICIENT

                    toggleHtml = `
                        <div class="toggle-container" onclick="event.stopPropagation()">
                            <button id="autoBuyerBtn" class="tab-btn" style="background: rgba(255,255,255,0.1); border-color: ${modeColor}; color: ${modeColor}; font-size: 0.8rem; padding: 0.2rem 0.5rem;">
                                Mode: ${mode.toUpperCase()}
                            </button>
                        </div>
                    `;
                }

                item.innerHTML = `
                    <div class="upgrade-icon">${u.icon}</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">${u.name} <span style="font-size: 0.8em; opacity: 0.7;">${levelText}</span></div>
                        <div class="upgrade-cost">${costText}</div>
                        ${toggleHtml}
                    </div>
                `;

                // Tooltip for Meta
                item.onmouseenter = (e) => {
                    tooltip.innerHTML = `
                        <div class="tooltip-header">${u.name}</div>
                        <div class="tooltip-stat">${descText}</div>
                        ${!isMaxed ? `<div class="tooltip-stat">Cost: <span>üç™ ${formatNumber(nextLevel.cost)}</span></div>` : ''}
                    `;
                    tooltip.style.display = 'block';
                    moveTooltip(e.clientX, e.clientY);
                };
                item.onmousemove = (e) => moveTooltip(e.clientX, e.clientY);
                item.onmouseleave = hideTooltip;

                metaList.appendChild(item);

                // Add Toggle Listener
                if (u.id === 'autoBuyer' && currentLevel > 0) {
                    const btn = document.getElementById('autoBuyerBtn');
                    if (btn) {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            cycleAutoBuyerMode();
                        });
                    }
                }
            });
        }

        // Fix: Update Upgrade Visuals (Enable/Disable)
        function updateUpgradeVisuals() {
            // Standard Upgrades
            const upgradeOrder = ['cursor', 'grandma', 'farm', 'mine', 'factory', 'bank', 'temple', 'wizardTower', 'shipment', 'alchemyLab', 'portal', 'timeMachine'];

            upgradeOrder.forEach((id, index) => {
                const u = state.upgrades[id];
                const el = document.getElementById(`upgrade-${u.id}`);
                if (!el) return;

                // Visibility Logic
                let isVisible = false;
                if (index === 0) {
                    isVisible = true; // First item always visible
                } else {
                    const prevId = upgradeOrder[index - 1];
                    if (state.upgrades[prevId].count > 0) {
                        isVisible = true;
                    }
                }

                if (isVisible) {
                    el.style.display = 'flex';
                } else {
                    el.style.display = 'none';
                }

                const cost = getCost(u.id);
                if (state.score >= cost) {
                    el.classList.remove('disabled');
                } else {
                    el.classList.add('disabled');
                }
                // Update cost text dynamically
                el.querySelector('.upgrade-cost').textContent = `üç™ ${formatNumber(cost)}`;
                el.querySelector('.upgrade-count').textContent = u.count;
            });

            // Meta Upgrades
            Object.values(state.metaUpgrades).forEach(u => {
                const el = document.getElementById(`meta-${u.id}`);
                const currentLevel = u.count;
                const isMaxed = currentLevel >= u.levels.length;

                if (isMaxed) {
                    el.classList.add('disabled');
                    el.querySelector('.upgrade-cost').textContent = "Maxed";
                    el.querySelector('.upgrade-name span').textContent = `Lvl ${currentLevel}`;
                    el.style.opacity = 0.5;
                } else {
                    const nextCost = u.levels[currentLevel].cost;
                    el.querySelector('.upgrade-cost').textContent = `üç™ ${formatNumber(nextCost)}`;
                    el.querySelector('.upgrade-name span').textContent = `Lvl ${currentLevel} ‚Üí ${currentLevel + 1}`;

                    if (state.score >= nextCost) {
                        el.classList.remove('disabled');
                    } else {
                        el.classList.add('disabled');
                    }
                }
            });

            // Stats Button Visibility
            if (state.metaUpgrades.analytics.count > 0) {
                statsBtn.style.display = 'block';
            }
        }

        // Core Logic: Click Cookie
        cookieBtn.addEventListener('mousedown', (e) => {
            // Heat Logic
            if (state.metaUpgrades.clickFrenzy.count > 0) {
                const frenzyLevel = state.metaUpgrades.clickFrenzy.count;
                // Level 4: Quick Ignition - +15 heat per click instead of +10
                const heatGain = (frenzyLevel >= 4) ? 15 : 10;

                // Level 6: Chain Reaction - At max heat, clicks add +5 heat (sustaining)
                if (heat >= 100 && frenzyLevel >= 6) {
                    heat = Math.min(150, heat + 5);
                } else {
                    heat = Math.min(150, heat + heatGain);
                }
                updateHeatVisuals();
            }

            // Calculate Click Power
            let clickPower = 1;
            const frenzyLevel = state.metaUpgrades.clickFrenzy.count;

            // Level 2: +1 cookie per click above 50% heat
            if (frenzyLevel >= 2 && heat > 50) {
                clickPower += 1;
            }

            if (heat >= 100) {
                clickPower = (frenzyLevel >= 3) ? 5 : 2;

                // Level 7: Blazing Strikes - +5 cookies per click at max heat
                if (frenzyLevel >= 7) {
                    clickPower += 5;
                }
            }

            state.score += clickPower;
            state.totalClicks++; // Legacy counter
            state.stats.totalClicks++; // New stats counter
            state.stats.totalCookies += clickPower;

            // Track click for CPS calculation
            if (state.metaUpgrades.clickFrenzy.count > 0) {
                trackClick();
            }

            updateUI();

            const text = (clickPower > 1) ? `+${clickPower} üî•` : "+1";
            spawnFloatingText(e.clientX, e.clientY, text);
            createParticles(e.clientX, e.clientY);
        });

        // Core Logic: Buy Upgrade
        function buyUpgrade(id) {
            const cost = getCost(id);
            if (state.score >= cost) {
                state.score -= cost;
                state.upgrades[id].count++;
                updateUI();
                // Fix: Removed synchronous saveGame() for performance
            }
        }

        // Meta Logic: Buy Meta Upgrade
        function buyMetaUpgrade(id) {
            const u = state.metaUpgrades[id];
            const currentLevel = u.count;

            if (currentLevel < u.levels.length) {
                const cost = u.levels[currentLevel].cost;
                if (state.score >= cost) {
                    state.score -= cost;
                    u.count++;
                    updateUI();
                    createMetaList(); // Re-render to update next level info
                }
            }
        }

        // Auto Buyer Logic
        function cycleAutoBuyerMode() {
            const modes = ['off', 'cheapest'];
            if (state.metaUpgrades.autoBuyer.count >= 4) {
                modes.push('efficient');
            }

            let currentIdx = modes.indexOf(state.settings.autoBuyerMode);
            if (currentIdx === -1) currentIdx = 0;

            const nextIdx = (currentIdx + 1) % modes.length;
            state.settings.autoBuyerMode = modes[nextIdx];

            createMetaList(); // Re-render button
            saveGame();
        }

        let autoBuyerTick = 0;
        function runAutoBuyer() {
            const mode = state.settings.autoBuyerMode;
            if (!mode || mode === 'off') return;

            const level = state.metaUpgrades.autoBuyer.count;
            if (level === 0) return;

            // Level 1: Every 3s (tick % 3 === 0)
            // Level 2: Every 1s
            // Level 3: Every 0.5s (runs twice per tick)

            autoBuyerTick++;
            if (level === 1 && autoBuyerTick % 3 !== 0) return;

            const iterations = (level >= 3 && mode === 'cheapest') ? 2 : 1;

            for (let i = 0; i < iterations; i++) {
                let targetId = null;

                if (mode === 'cheapest') {
                    // Cheapest Strategy
                    let minCost = Infinity;
                    Object.values(state.upgrades).forEach(u => {
                        const cost = getCost(u.id);
                        if (cost < minCost) {
                            minCost = cost;
                            targetId = u.id;
                        }
                    });
                    if (targetId && state.score < getCost(targetId)) targetId = null;
                } else if (mode === 'efficient' && level >= 4) {
                    // Smart Strategy (Best Efficiency - Only consider upgrades available in next 60s)
                    const upgradeOrder = ['cursor', 'grandma', 'farm', 'mine', 'factory', 'bank', 'temple', 'wizardTower', 'shipment', 'alchemyLab', 'portal', 'timeMachine'];
                    let maxEff = -1;
                    const currentCPS = getCPS();
                    const TIME_HORIZON = 60; // Only consider upgrades available in next 60 seconds

                    // Find the best efficiency among UNLOCKED upgrades available within 60s
                    upgradeOrder.forEach((id, index) => {
                        // Check unlock status
                        if (index > 0) {
                            const prevId = upgradeOrder[index - 1];
                            if (state.upgrades[prevId].count === 0) return; // Locked
                        }

                        const u = state.upgrades[id];
                        const cost = getCost(u.id);

                        // Calculate time to afford this upgrade
                        const shortfall = Math.max(0, cost - state.score);
                        const timeToAfford = currentCPS > 0 ? shortfall / currentCPS : Infinity;

                        // Only consider if available within 60 seconds
                        if (timeToAfford > TIME_HORIZON) return;

                        const eff = u.cps / cost;

                        if (eff > maxEff) {
                            maxEff = eff;
                            targetId = u.id;
                        }
                    });

                    // Only buy if we can afford the BEST one (within the 60s window)
                    if (targetId && state.score < getCost(targetId)) {
                        targetId = null; // Wait
                    }
                }

                if (targetId) {
                    buyUpgrade(targetId);

                    // Trigger animation for auto-bought item
                    const element = document.getElementById(`upgrade-${targetId}`);
                    if (element) {
                        element.classList.add('auto-bought');
                        // Remove class after animation completes
                        setTimeout(() => {
                            element.classList.remove('auto-bought');
                        }, 600);
                    }
                }
            }
        }

        // Heat Logic
        function updateHeat() {
            if (state.metaUpgrades.clickFrenzy.count === 0) return;

            const frenzyLevel = state.metaUpgrades.clickFrenzy.count;

            // Decay Rate
            let decay = 1.5; // Base decay
            if (frenzyLevel >= 2) decay = 0.75; // Slower decay

            if (heat > 0) {
                heat = Math.max(0, heat - decay);
                updateHeatVisuals();
            }

            // Level 8: Momentum - Update multiplier based on heat and clicking
            if (frenzyLevel >= 8) {
                updateMomentum();
            }
        }

        function updateHeatVisuals() {
            if (state.metaUpgrades.clickFrenzy.count > 0) {
                heatContainer.style.display = 'block';
                // Scale heat to percentage (150% max = 100% bar width)
                const heatPercent = (heat / 150) * 100;
                heatBar.style.width = `${heatPercent}%`;

                if (heat >= 100) {
                    heatContainer.classList.add('active');
                    const frenzyLevel = state.metaUpgrades.clickFrenzy.count;

                    // Build heat text based on active bonuses
                    let clickMult = (frenzyLevel >= 3) ? "x5" : "x2";
                    let bonusText = `MAX HEAT! (${clickMult} Clicks`;

                    // Level 7: Blazing Strikes
                    if (frenzyLevel >= 7) {
                        bonusText += " +5";
                    }

                    // Add Inferno Mode indicator
                    if (frenzyLevel >= 5) {
                        bonusText += " + 10% CPS";
                    }

                    // Level 8: Momentum - Show multiplier if significant
                    if (frenzyLevel >= 8 && momentumMultiplier > 1.01) {
                        bonusText += ` + ${momentumMultiplier.toFixed(2)}x CPS`;
                    }

                    bonusText += ")";

                    heatText.textContent = bonusText;
                } else {
                    heatContainer.classList.remove('active');
                }

                // Update max CPS display opacity based on heat
                updateMaxCpsDisplay();
            }
        }

        // Click Tracking Functions
        function trackClick() {
            const now = Date.now();
            clickTimestamps.push(now);

            // Remove clicks older than 60 seconds
            const sixtySecondsAgo = now - 60000;
            clickTimestamps = clickTimestamps.filter(timestamp => timestamp > sixtySecondsAgo);

            // Calculate clicks per second over 1-second intervals
            const oneSecondAgo = now - 1000;
            const clicksInLastSecond = clickTimestamps.filter(timestamp => timestamp > oneSecondAgo).length;

            // Update max if current rate is higher
            if (clicksInLastSecond > maxClicksPerSecond) {
                maxClicksPerSecond = clicksInLastSecond;
            }

            // Decay max value if no clicks in last 60 seconds match it
            const maxInWindow = calculateMaxClicksInWindow();
            if (maxInWindow < maxClicksPerSecond) {
                maxClicksPerSecond = maxInWindow;
            }

            updateMaxCpsDisplay();
        }

        function calculateMaxClicksInWindow() {
            if (clickTimestamps.length === 0) return 0;

            let max = 0;
            const now = Date.now();

            // Check each second in the last 60 seconds
            for (let i = 0; i < 60; i++) {
                const secondStart = now - (i * 1000);
                const secondEnd = secondStart - 1000;
                const clicksInSecond = clickTimestamps.filter(t => t <= secondStart && t > secondEnd).length;
                max = Math.max(max, clicksInSecond);
            }

            return max;
        }

        function updateMaxCpsDisplay() {
            if (state.metaUpgrades.clickFrenzy.count > 0) {
                // Check if there are any recent clicks (within last 60 seconds)
                const now = Date.now();
                const sixtySecondsAgo = now - 60000;
                const hasRecentClicks = clickTimestamps.some(t => t > sixtySecondsAgo);

                if (hasRecentClicks) {
                    maxCpsDisplay.style.display = 'block';
                    maxCpsValue.textContent = maxClicksPerSecond;

                    // Opacity based on heat (inverted - lower heat = more visible)
                    const opacity = 1 - (heat / 150) * 0.7; // Range from 1.0 to 0.3
                    maxCpsDisplay.style.opacity = Math.max(0.3, opacity);
                } else {
                    maxCpsDisplay.style.display = 'none';
                }
            } else {
                maxCpsDisplay.style.display = 'none';
            }
        }

        // Momentum System (Level 8)
        function updateMomentum() {
            // This runs every 100ms (same as heat decay)
            if (heat >= 100) {
                // Build momentum based on current clicking speed
                const now = Date.now();
                const oneSecondAgo = now - 1000;
                const currentClicksPerSecond = clickTimestamps.filter(t => t > oneSecondAgo).length;

                // Gain momentum based on clicking speed
                // Formula: (clicks/sec / 10) * 0.001 per tick (0.01 per second)
                // At 10 clicks/sec: +0.01 per second = +0.6 per minute
                // Cap at 3x multiplier
                const momentumGain = (currentClicksPerSecond / 10) * 0.001;
                momentumMultiplier = Math.min(3.0, momentumMultiplier + momentumGain);

                // Track time at max heat
                timeAtMaxHeat += 0.1; // 100ms = 0.1 seconds
            } else {
                // Decay momentum when not at max heat
                // Decay faster than it builds
                momentumMultiplier = Math.max(1.0, momentumMultiplier - 0.005);
                timeAtMaxHeat = 0; // Reset timer
            }
        }

        // Golden Cookie Logic
        function trySpawnGoldenCookie() {
            const level = state.metaUpgrades.luckyClover.count;
            if (level === 0) return;

            // Base chance: 1% per second (~1.6 mins)
            // Level 3: Double chance (2%)
            const chance = (level >= 3) ? 0.02 : 0.01;

            if (Math.random() < chance && !document.querySelector('.golden-cookie')) {
                spawnGoldenCookie();
            }
        }

        function spawnGoldenCookie() {
            const el = document.createElement('div');
            el.className = 'golden-cookie';
            el.textContent = 'üçÄ';
            el.style.left = `${Math.random() * 80 + 10}%`;
            el.style.top = `${Math.random() * 80 + 10}%`;

            el.onclick = (e) => {
                e.stopPropagation();
                const level = state.metaUpgrades.luckyClover.count;
                const cps = getCPS();
                // Reward: 15 mins of CPS (900s) or 30 mins (1800s)
                const seconds = (level >= 2) ? 1800 : 900;
                // Min reward 100 cookies if CPS is low
                const reward = Math.max(100, cps * seconds);

                state.score += reward;
                state.stats.totalCookies += reward;
                updateUI();

                spawnFloatingText(e.clientX, e.clientY, `+${formatNumber(reward)}!`);
                el.remove();
            };

            document.body.appendChild(el);

            // Auto-Click Logic (Golden Net)
            const netLevel = state.metaUpgrades.goldenNet.count;
            if (netLevel > 0) {
                let delay = 5000;
                if (netLevel >= 2) delay = 2000;
                if (netLevel >= 3) delay = 100;

                setTimeout(() => {
                    if (el.parentNode) el.click();
                }, delay);
            }

            // Despawn after 15s
            setTimeout(() => {
                if (el.parentNode) el.remove();
            }, 15000);
        }

        // Time Warp Logic
        function checkOfflineEarnings() {
            const level = state.metaUpgrades.timeWarp.count;
            if (level === 0) return;

            const now = Date.now();
            const lastSave = state.stats.lastSaveTime || now;
            const diffMs = now - lastSave;
            const diffHours = diffMs / (1000 * 60 * 60);

            if (diffMs < 60000) return; // Less than 1 min, ignore

            let efficiency = 0.1;
            let maxHours = 1;

            if (level >= 2) { efficiency = 0.25; maxHours = 4; }
            if (level >= 3) { efficiency = 0.50; maxHours = 24; }

            const effectiveHours = Math.min(diffHours, maxHours);
            const cps = getCPS();

            if (cps > 0) {
                const earnings = cps * (effectiveHours * 3600) * efficiency;
                if (earnings > 0) {
                    state.score += earnings;
                    state.stats.totalCookies += earnings;
                    alert(`Welcome back! Time Warp generated ${formatNumber(earnings)} cookies while you were away.`);
                    updateUI();
                }
            }
        }

        // Stats Logic
        let statsChart = null;
        let statsInterval = null;

        function recordAnalyticsData() {
            // Only record if we have Analytics Lvl 4 unlocked
            // OR if we want to track history in background (optional, but good for UX)
            // Let's record always so data is there when they buy it.

            const now = Date.now();
            const totalUpgrades = Object.values(state.upgrades).reduce((acc, u) => acc + u.count, 0);

            state.stats.history.push({
                timestamp: now,
                cookies: state.score,
                cps: getCPS(),
                upgrades: totalUpgrades
            });

            // Dynamic History Limit based on Analytics Level
            const analyticsLevel = state.metaUpgrades.analytics.count;
            let maxHistory = 0;
            if (analyticsLevel >= 2) maxHistory = 50;
            if (analyticsLevel >= 3) maxHistory = 100;
            if (analyticsLevel >= 4) maxHistory = 200;
            if (analyticsLevel >= 5) maxHistory = 400;
            if (analyticsLevel >= 6) maxHistory = 800;
            if (analyticsLevel >= 7) maxHistory = 2000;

            // Always keep at least a small buffer if they have no analytics yet, 
            // so when they buy level 2 they see something immediately.
            if (maxHistory === 0) maxHistory = 20;

            while (state.stats.history.length > maxHistory) {
                state.stats.history.shift();
            }
        }

        function showStats() {
            updateStatsContent();
            statsModal.classList.add('active');

            // Live Update Loop
            if (statsInterval) clearInterval(statsInterval);
            statsInterval = setInterval(() => {
                updateStatsContent();
                if (state.metaUpgrades.analytics.count >= 2) {
                    renderChart();
                }
            }, 1000);

            if (state.metaUpgrades.analytics.count >= 2) {
                renderChart();
            }
        }

        function updateStatsContent() {
            const timePlayed = ((Date.now() - state.stats.startTime) / 1000 / 60).toFixed(1);
            const analyticsLevel = state.metaUpgrades.analytics.count;

            // Update Text
            statsText.innerHTML = `
                <div class="stat-row">
                    <span class="stat-label">Total Cookies Earned</span>
                    <span class="stat-value">${formatNumber(state.stats.totalCookies)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Clicks</span>
                    <span class="stat-value">${formatNumber(state.stats.totalClicks)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Time Played</span>
                    <span class="stat-value">${timePlayed} mins</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Current CPS</span>
                    <span class="stat-value">${formatCPS(getCPS())}</span>
                </div>
            `;

            // Handle Chart Visibility
            if (analyticsLevel >= 2) {
                statsChartContainer.style.display = 'block';
            } else {
                statsChartContainer.style.display = 'none';
            }
        }

        function closeStatsModal() {
            statsModal.classList.remove('active');
            if (statsInterval) clearInterval(statsInterval);
        }

        function renderChart() {
            const ctx = document.getElementById('statsChart');
            if (!ctx) return;

            const level = state.metaUpgrades.analytics.count;
            const labels = state.stats.history.map((h, i) => i);
            const cookiesData = state.stats.history.map(h => h.cookies);
            const cpsData = state.stats.history.map(h => h.cps);
            const upgradesData = state.stats.history.map(h => h.upgrades);

            const datasets = [];

            // Level 2: Cookies
            if (level >= 2) {
                datasets.push({
                    label: 'Cookies',
                    data: cookiesData,
                    borderColor: '#fbbf24',
                    yAxisID: 'y',
                    tension: 0 // Straight lines
                });
            }

            // Level 3: CPS
            if (level >= 3) {
                datasets.push({
                    label: 'CPS',
                    data: cpsData,
                    borderColor: '#a855f7',
                    yAxisID: 'y1',
                    tension: 0 // Straight lines
                });
            }

            // Level 6: Upgrades
            if (level >= 6) {
                datasets.push({
                    label: 'Upgrades',
                    data: upgradesData,
                    borderColor: '#3b82f6',
                    yAxisID: 'y1', // Share right axis with CPS
                    borderDash: [5, 5],
                    tension: 0 // Straight lines
                });
            }

            if (statsChart) {
                statsChart.data.labels = labels;
                statsChart.data.datasets = datasets;
                statsChart.update('none'); // Update without animation for performance
            } else {
                statsChart = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        animation: false, // Disable animation for live updates
                        responsive: true,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            x: { display: false },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: { drawOnChartArea: false }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: '#fff' } }
                        }
                    }
                });
            }
        }

        // UI Update
        function updateUI() {
            scoreEl.textContent = formatNumber(state.score);
            cpsEl.textContent = `${formatCPS(getCPS())} CPS`;
            document.title = `${formatNumber(state.score)} Cookies - Cosmic Clicker`;

            updateUpgradeVisuals(); // Check affordability
            updateTechVisuals(); // Check tech affordability/unlocks
            checkNotifications(); // Check for notifications
        }

        function checkNotifications() {
            // Tech Notifications
            let techNotification = false;
            Object.values(state.tech).forEach(t => {
                if (!t.purchased && state.score >= t.cost) {
                    // Check if unlocked
                    const triggerBuilding = state.upgrades[t.trigger.building];
                    if (triggerBuilding && triggerBuilding.count >= t.trigger.count) {
                        techNotification = true;
                    }
                }
            });
            if (techNotification) tabTech.classList.add('has-notification');
            else tabTech.classList.remove('has-notification');

            // Meta Notifications
            let metaNotification = false;
            Object.values(state.metaUpgrades).forEach(u => {
                const currentLevel = u.count;
                if (currentLevel < u.levels.length) {
                    const cost = u.levels[currentLevel].cost;
                    if (state.score >= cost) {
                        metaNotification = true;
                    }
                }
            });
            if (metaNotification) tabMeta.classList.add('has-notification');
            else tabMeta.classList.remove('has-notification');
        }

        // Floating Text Effect
        function spawnFloatingText(x, y, text) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.textContent = text;
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // Particle Effect
        function createParticles(x, y) {
            for (let i = 0; i < 6; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                document.body.appendChild(p);

                const size = Math.random() * 8 + 4;
                p.style.width = `${size}px`;
                p.style.height = `${size}px`;
                p.style.left = `${x}px`;
                p.style.top = `${y}px`;

                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * 50 + 20;
                const tx = Math.cos(angle) * velocity;
                const ty = Math.sin(angle) * velocity;

                p.animate([
                    { transform: 'translate(0, 0)', opacity: 1 },
                    { transform: `translate(${tx}px, ${ty}px)`, opacity: 0 }
                ], {
                    duration: 500,
                    easing: 'ease-out'
                }).onfinish = () => p.remove();
            }
        }

        // Game Loop
        let lastTime = performance.now();
        let accumulator = 0;

        function gameLoop(currentTime) {
            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            if (dt > 0) {
                const cps = getCPS();
                if (cps > 0) {
                    // Add fractional cookies
                    const amount = cps * dt;
                    state.score += amount;
                    state.stats.totalCookies += amount;
                    updateUI();
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // Persistence
        function saveGame() {
            if (isResetting) return; // Don't save if resetting
            state.stats.lastSaveTime = Date.now();
            localStorage.setItem('cosmicClickerSave', JSON.stringify(state));
        }

        function loadGame() {
            const saved = localStorage.getItem('cosmicClickerSave');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Merge saved state with default structure to handle version updates
                    state = {
                        ...defaultState,
                        ...parsed,
                        upgrades: { ...defaultState.upgrades },
                        metaUpgrades: { ...defaultState.metaUpgrades },
                        stats: { ...defaultState.stats, ...parsed.stats }
                    };

                    // Migration: autoBuyerEnabled -> autoBuyerMode
                    if (parsed.settings && parsed.settings.autoBuyerEnabled !== undefined) {
                        state.settings.autoBuyerMode = parsed.settings.autoBuyerEnabled ? 'cheapest' : 'off';
                        delete state.settings.autoBuyerEnabled;
                    }
                    if (!state.settings.autoBuyerMode) state.settings.autoBuyerMode = 'off';

                    // Fix: Restore upgrade counts carefully
                    Object.keys(parsed.upgrades).forEach(key => {
                        if (state.upgrades[key]) {
                            state.upgrades[key].count = parsed.upgrades[key].count;
                        }
                    });

                    // Restore Meta Upgrades
                    if (parsed.metaUpgrades) {
                        Object.keys(parsed.metaUpgrades).forEach(key => {
                            if (state.metaUpgrades[key]) {
                                state.metaUpgrades[key].count = parsed.metaUpgrades[key].count;
                            }
                        });
                    }
                } catch (e) {
                    console.error("Save file corrupted", e);
                }
            } else {
                // First time playing - ensure startTime is set to now
                state.stats.startTime = Date.now();
            }
        }

        // Reset


        // Tooltip Logic
        function showTooltip(id, x, y) {
            const u = state.upgrades[id];
            const cost = getCost(id);
            const totalCps = u.cps * u.count;

            // Advanced Analytics
            const analyticsLevel = state.metaUpgrades.analytics.count;
            let extraStats = '';

            if (analyticsLevel >= 2) {
                const efficiency = (u.cps / cost * 1000).toFixed(2); // CPS per 1k cookies
                extraStats += `<div class="tooltip-stat">Eff: <span>${efficiency} CPK</span></div>`;
            }

            if (analyticsLevel >= 3) {
                let timeToWait = "Ready";
                if (state.score < cost) {
                    const cps = getCPS();
                    if (cps > 0) {
                        const seconds = (cost - state.score) / cps;
                        if (seconds < 60) timeToWait = `${seconds.toFixed(0)}s`;
                        else timeToWait = `${(seconds / 60).toFixed(1)}m`;
                    } else {
                        timeToWait = "‚àû";
                    }
                }
                extraStats += `<div class="tooltip-stat">Wait: <span>${timeToWait}</span></div>`;
            }

            tooltip.innerHTML = `
                <div class="tooltip-header">${u.name}</div>
                <div class="tooltip-stat">Cost: <span>üç™ ${formatNumber(cost)}</span></div>
                <div class="tooltip-stat">CPS: <span>${formatCPS(u.cps)}</span></div>
                <div class="tooltip-stat">Owned: <span>${u.count}</span></div>
                <div class="tooltip-stat">Total CPS: <span>${formatCPS(totalCps)}</span></div>
                ${extraStats}
            `;

            tooltip.style.display = 'block';
            moveTooltip(x, y);
        }

        function moveTooltip(x, y) {
            // Keep tooltip within bounds
            const width = tooltip.offsetWidth;
            const height = tooltip.offsetHeight;

            let left = x - width - 10;
            let top = y - height / 2;

            if (left < 0) left = x + 20; // Flip to right if too close to left edge
            if (top < 0) top = 10;
            if (top + height > window.innerHeight) top = window.innerHeight - height - 10;

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        // Start
        init();

    </script>
</body>

</html>