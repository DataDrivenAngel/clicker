<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Cookie Clicker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>

    <!-- Gear Icon -->
    <button id="settingsBtn" class="settings-icon" aria-label="Open settings">‚öôÔ∏è</button>

    <div id="game-container">
        <!-- Left Zone -->
        <div class="click-zone">
            <div class="score-container">
                <span id="score">0</span>
                <div class="score-label">Cookies</div>
                <div id="cps-display">per second: 0.0</div>

                <!-- Heat Meter -->
                <div id="heat-container" class="heat-container">
                    <div id="heat-bar" class="heat-bar"></div>
                    <div class="heat-text">MAX HEAT! (x2 Clicks)</div>
                </div>

                <!-- Max Clicks Per Second Display -->
                <div id="max-cps-display" class="max-cps-display" style="display: none;">
                    Max: <span id="max-cps-value">0</span> clicks/sec
                </div>
            </div>

            <button id="cookieBtn" class="cookie-btn" aria-label="Click cookie to earn cookies">
                <div class="cookie-visual" id="cookieVisual">
                    <!-- Chips generated by JS -->
                </div>
            </button>
        </div>

        <!-- Right Zone -->
        <div class="upgrades-panel">
            <div class="panel-header">
                <span>Store</span>
                <div class="store-tabs">
                    <button id="tab-structures" class="tab-btn active"
                        aria-label="View structures tab">Structures</button>
                    <button id="tab-tech" class="tab-btn" aria-label="View tech upgrades tab">Tech</button>
                    <button id="tab-meta" class="tab-btn" aria-label="View meta upgrades tab">Meta</button>
                    <button id="statsBtn" class="reset-btn" aria-label="View statistics"
                        style="display: none; background: rgba(147, 51, 234, 0.1); color: #a855f7; border-color: rgba(147, 51, 234, 0.2); margin-left: 0.5rem;">Stats</button>
                </div>
            </div>
            <div id="upgrades-list">
                <!-- Upgrades injected by JS -->
            </div>
            <div id="tech-list" style="display: none; overflow-y: auto; flex-grow: 1; padding-right: 0.5rem;">
                <!-- Tech injected by JS -->
            </div>
            <div id="meta-list" style="display: none; overflow-y: auto; flex-grow: 1; padding-right: 0.5rem;">
                <!-- Meta Upgrades injected by JS -->
            </div>
        </div>


    </div>

    <!-- Tooltip Element -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Stats Modal -->
    <div id="statsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span>Statistics</span>
                <button class="close-modal" id="closeStats" aria-label="Close statistics modal">√ó</button>
            </div>
            <div id="statsContent">
                <div id="statsText">
                    <!-- Stats Text injected by JS -->
                </div>
                <div id="statsChartContainer"
                    style="display: none; margin-top: 2rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div id="chartFilters" style="display: none; margin-bottom: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="chart-filter-btn active" data-filter="all">All Time</button>
                        <button class="chart-filter-btn" data-filter="day">Last Day</button>
                        <button class="chart-filter-btn" data-filter="hour">Last Hour</button>
                        <button class="chart-filter-btn" data-filter="15min">Last 15 Min</button>
                        <button class="chart-filter-btn" data-filter="1min">Last Minute</button>
                    </div>
                    <div id="seriesFilters" style="display: none; margin-bottom: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;"></div>
                    <canvas id="statsChart"></canvas>
                </div>
                <div id="accuracyChartContainer" style="display: none; margin-top: 2rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="color: rgba(255,255,255,0.7); margin-bottom: 1rem; font-size: 1.2rem;">Auto-Click Accuracy</h3>
                    <canvas id="accuracyChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span>Settings</span>
                <button class="close-modal" id="closeSettings" aria-label="Close settings modal">√ó</button>
            </div>
            <div class="settings-content">
                <p style="color: var(--text-muted); margin-bottom: 2rem;">Manage your game data and preferences.</p>

                <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                    <button id="exportBtn" class="reset-btn" aria-label="Export save data"
                        style="flex: 1; background: rgba(59, 130, 246, 0.1); color: #3b82f6; border-color: rgba(59, 130, 246, 0.2);">
                        üíæ Export Save
                    </button>
                    <button id="importBtn" class="reset-btn" aria-label="Import save data"
                        style="flex: 1; background: rgba(16, 185, 129, 0.1); color: #10b981; border-color: rgba(16, 185, 129, 0.2);">
                        üìÇ Import Save
                    </button>
                </div>
                <input type="file" id="importFile" style="display: none" accept=".txt,.json">

                <button id="resetBtn" class="reset-btn" aria-label="Wipe all save data"
                    style="width: 100%; padding: 1rem; font-size: 1rem;">
                    ‚ö†Ô∏è Wipe Save Data
                </button>
                <p style="font-size: 0.8rem; color: rgba(255,255,255,0.3); margin-top: 2rem; text-align: center;">
                    Cosmic Clicker v1.4
                </p>
            </div>
        </div>
    </div>

    <script>
        // Game State
        const defaultState = {
            score: 0,
            totalClicks: 0,
            startTime: Date.now(),
            upgrades: {
                cursor: { id: 'cursor', name: 'Cursor', baseCost: 15, cps: 0.1, count: 0, icon: 'üëÜ' },
                grandma: { id: 'grandma', name: 'Grandma', baseCost: 100, cps: 1, count: 0, icon: 'üëµ' },
                farm: { id: 'farm', name: 'Cookie Farm', baseCost: 1100, cps: 8, count: 0, icon: 'üöú' },
                mine: { id: 'mine', name: 'Mine', baseCost: 12000, cps: 47, count: 0, icon: '‚õèÔ∏è' },
                factory: { id: 'factory', name: 'Factory', baseCost: 130000, cps: 260, count: 0, icon: 'üè≠' },
                bank: { id: 'bank', name: 'Bank', baseCost: 1400000, cps: 1400, count: 0, icon: 'üè¶' },
                temple: { id: 'temple', name: 'Temple', baseCost: 20000000, cps: 7800, count: 0, icon: 'üèõÔ∏è' },
                wizardTower: { id: 'wizardTower', name: 'Wizard Tower', baseCost: 330000000, cps: 44000, count: 0, icon: 'üßô‚Äç‚ôÇÔ∏è' },
                shipment: { id: 'shipment', name: 'Shipment', baseCost: 5100000000, cps: 260000, count: 0, icon: 'üöÄ' },
                alchemyLab: { id: 'alchemyLab', name: 'Alchemy Lab', baseCost: 75000000000, cps: 1600000, count: 0, icon: '‚öóÔ∏è' },
                portal: { id: 'portal', name: 'Portal', baseCost: 1000000000000, cps: 10000000, count: 0, icon: 'üåÄ' },
                timeMachine: { id: 'timeMachine', name: 'Time Machine', baseCost: 14000000000000, cps: 65000000, count: 0, icon: '‚è≥' }
            },
            tech: {
                // Format: id: { name, cost, desc, trigger: { building, count }, effect: { type: 'mult', target, value }, purchased: false }
                ThumbTrick: { id: 'ThumbTrick', name: 'Weird Thumb Trick', cost: 25, desc: 'Cursor clicks are twice as efficient.', trigger: { building: 'cursor', count: 2 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üëÜ' },
                ThumbTrick2: { id: 'ThumbTrick2', name: 'Weird Thumb Trick II', cost: 50, desc: 'Cursor clicks are twice as efficient.', trigger: { building: 'cursor', count: 5 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üëÜ' },
                reinforcedIndex: { id: 'reinforcedIndex', name: 'Reinforced Index Finger', cost: 100, desc: 'Cursor clicks are twice as efficient.', trigger: { building: 'cursor', count: 10 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üëÜ' },
                carpalTunnel: { id: 'carpalTunnel', name: 'Carpal Tunnel Prevention', cost: 500, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 25 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üß§' },
                ambidextrous: { id: 'ambidextrous', name: 'Ambidextrous', cost: 10000, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 50 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: '‚úåÔ∏è' },
                thumbWar: { id: 'thumbWar', name: 'Thumb War Champion', cost: 25000, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 75 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üëä' },
                fingerPuppet: { id: 'fingerPuppet', name: 'Finger Puppet Mastery', cost: 50000, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 100 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üñêÔ∏è' },
                magicDisappear: { id: 'magicDisappear', name: 'Failed Magic Disappearing Act', cost: 100000, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 150 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üé©' },
                rubberFinger: { id: 'rubberFinger', name: 'Rubber Finger Trick', cost: 250000, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 200 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'ü§è' },
                fingerSnap: { id: 'fingerSnap', name: 'Finger Snap Illusion', cost: 500000, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 250 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'ü´∞' },
                thumbPiano: { id: 'thumbPiano', name: 'Thumb Piano Virtuoso', cost: 1000000, desc: 'Cursors are twice as efficient.', trigger: { building: 'cursor', count: 300 }, effect: { type: 'mult', target: 'cursor', value: 2 }, purchased: false, icon: 'üéπ' },

                lubricatedDentures: { id: 'lubricatedDentures', name: 'Lubricated Dentures', cost: 1000, desc: 'Grandmas are twice as efficient.', trigger: { building: 'grandma', count: 10 }, effect: { type: 'mult', target: 'grandma', value: 2 }, purchased: false, icon: 'ü¶∑' },
                pruneJuice: { id: 'pruneJuice', name: 'Prune Juice', cost: 5000, desc: 'Grandmas are twice as efficient.', trigger: { building: 'grandma', count: 25 }, effect: { type: 'mult', target: 'grandma', value: 2 }, purchased: false, icon: 'ü•§' },
                doubleRollingPin: { id: 'doubleRollingPin', name: 'Double Rolling Pin', cost: 50000, desc: 'Grandmas are twice as efficient.', trigger: { building: 'grandma', count: 50 }, effect: { type: 'mult', target: 'grandma', value: 2 }, purchased: false, icon: 'ü•ñ' },

                cheapHoes: { id: 'cheapHoes', name: 'Cheap Hoes', cost: 11000, desc: 'Farms are twice as efficient.', trigger: { building: 'farm', count: 10 }, effect: { type: 'mult', target: 'farm', value: 2 }, purchased: false, icon: 'ÔøΩ' },
                fertilizer: { id: 'fertilizer', name: 'Fertilizer', cost: 55000, desc: 'Farms are twice as efficient.', trigger: { building: 'farm', count: 25 }, effect: { type: 'mult', target: 'farm', value: 2 }, purchased: false, icon: 'üí©' },

                sturdyPicks: { id: 'sturdyPicks', name: 'Sturdy Picks', cost: 120000, desc: 'Mines are twice as efficient.', trigger: { building: 'mine', count: 10 }, effect: { type: 'mult', target: 'mine', value: 2 }, purchased: false, icon: '‚õèÔ∏è' },
                boreDrill: { id: 'boreDrill', name: 'Bore Drill', cost: 600000, desc: 'Mines are twice as efficient.', trigger: { building: 'mine', count: 25 }, effect: { type: 'mult', target: 'mine', value: 2 }, purchased: false, icon: 'üî©' },

                // Factory Tech Upgrades
                factory10: { id: 'factory10', name: 'Automated Assembly', cost: 1300000, desc: 'Factories are twice as efficient.', trigger: { building: 'factory', count: 10 }, effect: { type: 'mult', target: 'factory', value: 2 }, purchased: false, icon: 'üè≠' },
                factory25: { id: 'factory25', name: 'Quality Control', cost: 6500000, desc: 'Factories are twice as efficient.', trigger: { building: 'factory', count: 25 }, effect: { type: 'mult', target: 'factory', value: 2 }, purchased: false, icon: 'üè≠' },
                factory50: { id: 'factory50', name: 'Mass Production', cost: 13000000, desc: 'Factories are twice as efficient.', trigger: { building: 'factory', count: 50 }, effect: { type: 'mult', target: 'factory', value: 2 }, purchased: false, icon: 'üè≠' },
                factory100: { id: 'factory100', name: 'Industrial Revolution', cost: 65000000, desc: 'Factories are twice as efficient.', trigger: { building: 'factory', count: 100 }, effect: { type: 'mult', target: 'factory', value: 2 }, purchased: false, icon: 'üè≠' },
                factory250: { id: 'factory250', name: 'Smart Factories', cost: 325000000, desc: 'Factories are twice as efficient.', trigger: { building: 'factory', count: 250 }, effect: { type: 'mult', target: 'factory', value: 2 }, purchased: false, icon: 'üè≠' },
                factory500: { id: 'factory500', name: 'Nanotech Assembly', cost: 650000000, desc: 'Factories are twice as efficient.', trigger: { building: 'factory', count: 500 }, effect: { type: 'mult', target: 'factory', value: 2 }, purchased: false, icon: 'üè≠' },
                factory750: { id: 'factory750', name: 'Quantum Manufacturing', cost: 975000000, desc: 'Factories are twice as efficient.', trigger: { building: 'factory', count: 750 }, effect: { type: 'mult', target: 'factory', value: 2 }, purchased: false, icon: 'üè≠' },
                factory1000: { id: 'factory1000', name: 'Infinite Production', cost: 1300000000, desc: 'Factories are twice as efficient.', trigger: { building: 'factory', count: 1000 }, effect: { type: 'mult', target: 'factory', value: 2 }, purchased: false, icon: 'üè≠' },

                // Bank Tech Upgrades
                bank10: { id: 'bank10', name: 'Interest Rates', cost: 14000000, desc: 'Banks are twice as efficient.', trigger: { building: 'bank', count: 10 }, effect: { type: 'mult', target: 'bank', value: 2 }, purchased: false, icon: 'üè¶' },
                bank25: { id: 'bank25', name: 'Compound Interest', cost: 70000000, desc: 'Banks are twice as efficient.', trigger: { building: 'bank', count: 25 }, effect: { type: 'mult', target: 'bank', value: 2 }, purchased: false, icon: 'üè¶' },
                bank50: { id: 'bank50', name: 'High-Yield Savings', cost: 140000000, desc: 'Banks are twice as efficient.', trigger: { building: 'bank', count: 50 }, effect: { type: 'mult', target: 'bank', value: 2 }, purchased: false, icon: 'üè¶' },
                bank100: { id: 'bank100', name: 'Cryptocurrency Mining', cost: 700000000, desc: 'Banks are twice as efficient.', trigger: { building: 'bank', count: 100 }, effect: { type: 'mult', target: 'bank', value: 2 }, purchased: false, icon: 'üè¶' },
                bank250: { id: 'bank250', name: 'Quantum Banking', cost: 3500000000, desc: 'Banks are twice as efficient.', trigger: { building: 'bank', count: 250 }, effect: { type: 'mult', target: 'bank', value: 2 }, purchased: false, icon: 'üè¶' },
                bank500: { id: 'bank500', name: 'Interdimensional Finance', cost: 7000000000, desc: 'Banks are twice as efficient.', trigger: { building: 'bank', count: 500 }, effect: { type: 'mult', target: 'bank', value: 2 }, purchased: false, icon: 'üè¶' },
                bank750: { id: 'bank750', name: 'Time Travel Loans', cost: 10500000000, desc: 'Banks are twice as efficient.', trigger: { building: 'bank', count: 750 }, effect: { type: 'mult', target: 'bank', value: 2 }, purchased: false, icon: 'üè¶' },
                bank1000: { id: 'bank1000', name: 'Infinite Wealth', cost: 14000000000, desc: 'Banks are twice as efficient.', trigger: { building: 'bank', count: 1000 }, effect: { type: 'mult', target: 'bank', value: 2 }, purchased: false, icon: 'üè¶' },

                // Temple Tech Upgrades
                temple10: { id: 'temple10', name: 'Divine Rituals', cost: 200000000, desc: 'Temples are twice as efficient.', trigger: { building: 'temple', count: 10 }, effect: { type: 'mult', target: 'temple', value: 2 }, purchased: false, icon: 'üèõÔ∏è' },
                temple25: { id: 'temple25', name: 'Sacred Geometry', cost: 1000000000, desc: 'Temples are twice as efficient.', trigger: { building: 'temple', count: 25 }, effect: { type: 'mult', target: 'temple', value: 2 }, purchased: false, icon: 'üèõÔ∏è' },
                temple50: { id: 'temple50', name: 'Enlightenment', cost: 2000000000, desc: 'Temples are twice as efficient.', trigger: { building: 'temple', count: 50 }, effect: { type: 'mult', target: 'temple', value: 2 }, purchased: false, icon: 'üèõÔ∏è' },
                temple100: { id: 'temple100', name: 'Cosmic Alignment', cost: 10000000000, desc: 'Temples are twice as efficient.', trigger: { building: 'temple', count: 100 }, effect: { type: 'mult', target: 'temple', value: 2 }, purchased: false, icon: 'üèõÔ∏è' },
                temple250: { id: 'temple250', name: 'Multiversal Prayers', cost: 50000000000, desc: 'Temples are twice as efficient.', trigger: { building: 'temple', count: 250 }, effect: { type: 'mult', target: 'temple', value: 2 }, purchased: false, icon: 'üèõÔ∏è' },
                temple500: { id: 'temple500', name: 'Divine Intervention', cost: 100000000000, desc: 'Temples are twice as efficient.', trigger: { building: 'temple', count: 500 }, effect: { type: 'mult', target: 'temple', value: 2 }, purchased: false, icon: 'üèõÔ∏è' },
                temple750: { id: 'temple750', name: 'God Mode', cost: 150000000000, desc: 'Temples are twice as efficient.', trigger: { building: 'temple', count: 750 }, effect: { type: 'mult', target: 'temple', value: 2 }, purchased: false, icon: 'üèõÔ∏è' },
                temple1000: { id: 'temple1000', name: 'Infinite Faith', cost: 200000000000, desc: 'Temples are twice as efficient.', trigger: { building: 'temple', count: 1000 }, effect: { type: 'mult', target: 'temple', value: 2 }, purchased: false, icon: 'üèõÔ∏è' },

                // Wizard Tower Tech Upgrades
                wizardTower10: { id: 'wizardTower10', name: 'Arcane Amplification', cost: 3300000000, desc: 'Wizard Towers are twice as efficient.', trigger: { building: 'wizardTower', count: 10 }, effect: { type: 'mult', target: 'wizardTower', value: 2 }, purchased: false, icon: 'üßô‚Äç‚ôÇÔ∏è' },
                wizardTower25: { id: 'wizardTower25', name: 'Mana Crystals', cost: 16500000000, desc: 'Wizard Towers are twice as efficient.', trigger: { building: 'wizardTower', count: 25 }, effect: { type: 'mult', target: 'wizardTower', value: 2 }, purchased: false, icon: 'üßô‚Äç‚ôÇÔ∏è' },
                wizardTower50: { id: 'wizardTower50', name: 'Spell Automation', cost: 33000000000, desc: 'Wizard Towers are twice as efficient.', trigger: { building: 'wizardTower', count: 50 }, effect: { type: 'mult', target: 'wizardTower', value: 2 }, purchased: false, icon: 'üßô‚Äç‚ôÇÔ∏è' },
                wizardTower100: { id: 'wizardTower100', name: 'Eldritch Knowledge', cost: 165000000000, desc: 'Wizard Towers are twice as efficient.', trigger: { building: 'wizardTower', count: 100 }, effect: { type: 'mult', target: 'wizardTower', value: 2 }, purchased: false, icon: 'üßô‚Äç‚ôÇÔ∏è' },
                wizardTower250: { id: 'wizardTower250', name: 'Dimensional Magic', cost: 825000000000, desc: 'Wizard Towers are twice as efficient.', trigger: { building: 'wizardTower', count: 250 }, effect: { type: 'mult', target: 'wizardTower', value: 2 }, purchased: false, icon: 'üßô‚Äç‚ôÇÔ∏è' },
                wizardTower500: { id: 'wizardTower500', name: 'Infinite Mana', cost: 1650000000000, desc: 'Wizard Towers are twice as efficient.', trigger: { building: 'wizardTower', count: 500 }, effect: { type: 'mult', target: 'wizardTower', value: 2 }, purchased: false, icon: 'üßô‚Äç‚ôÇÔ∏è' },
                wizardTower750: { id: 'wizardTower750', name: 'Godlike Sorcery', cost: 2475000000000, desc: 'Wizard Towers are twice as efficient.', trigger: { building: 'wizardTower', count: 750 }, effect: { type: 'mult', target: 'wizardTower', value: 2 }, purchased: false, icon: 'üßô‚Äç‚ôÇÔ∏è' },
                wizardTower1000: { id: 'wizardTower1000', name: 'Arcane Supremacy', cost: 3300000000000, desc: 'Wizard Towers are twice as efficient.', trigger: { building: 'wizardTower', count: 1000 }, effect: { type: 'mult', target: 'wizardTower', value: 2 }, purchased: false, icon: 'üßô‚Äç‚ôÇÔ∏è' },

                // Shipment Tech Upgrades
                shipment10: { id: 'shipment10', name: 'Cargo Optimization', cost: 51000000000, desc: 'Shipments are twice as efficient.', trigger: { building: 'shipment', count: 10 }, effect: { type: 'mult', target: 'shipment', value: 2 }, purchased: false, icon: 'üöÄ' },
                shipment25: { id: 'shipment25', name: 'Interstellar Routes', cost: 255000000000, desc: 'Shipments are twice as efficient.', trigger: { building: 'shipment', count: 25 }, effect: { type: 'mult', target: 'shipment', value: 2 }, purchased: false, icon: 'üöÄ' },
                shipment50: { id: 'shipment50', name: 'Warp Drives', cost: 510000000000, desc: 'Shipments are twice as efficient.', trigger: { building: 'shipment', count: 50 }, effect: { type: 'mult', target: 'shipment', value: 2 }, purchased: false, icon: 'üöÄ' },
                shipment100: { id: 'shipment100', name: 'Quantum Shipping', cost: 2550000000000, desc: 'Shipments are twice as efficient.', trigger: { building: 'shipment', count: 100 }, effect: { type: 'mult', target: 'shipment', value: 2 }, purchased: false, icon: 'üöÄ' },
                shipment250: { id: 'shipment250', name: 'Multiversal Logistics', cost: 12750000000000, desc: 'Shipments are twice as efficient.', trigger: { building: 'shipment', count: 250 }, effect: { type: 'mult', target: 'shipment', value: 2 }, purchased: false, icon: 'üöÄ' },
                shipment500: { id: 'shipment500', name: 'Instant Delivery', cost: 25500000000000, desc: 'Shipments are twice as efficient.', trigger: { building: 'shipment', count: 500 }, effect: { type: 'mult', target: 'shipment', value: 2 }, purchased: false, icon: 'üöÄ' },
                shipment750: { id: 'shipment750', name: 'Time-Space Freight', cost: 38250000000000, desc: 'Shipments are twice as efficient.', trigger: { building: 'shipment', count: 750 }, effect: { type: 'mult', target: 'shipment', value: 2 }, purchased: false, icon: 'üöÄ' },
                shipment1000: { id: 'shipment1000', name: 'Omni-Shipping', cost: 51000000000000, desc: 'Shipments are twice as efficient.', trigger: { building: 'shipment', count: 1000 }, effect: { type: 'mult', target: 'shipment', value: 2 }, purchased: false, icon: 'üöÄ' },

                // Alchemy Lab Tech Upgrades
                alchemyLab10: { id: 'alchemyLab10', name: 'Transmutation Circles', cost: 750000000000, desc: 'Alchemy Labs are twice as efficient.', trigger: { building: 'alchemyLab', count: 10 }, effect: { type: 'mult', target: 'alchemyLab', value: 2 }, purchased: false, icon: '‚öóÔ∏è' },
                alchemyLab25: { id: 'alchemyLab25', name: 'Philosopher\'s Stone', cost: 3750000000000, desc: 'Alchemy Labs are twice as efficient.', trigger: { building: 'alchemyLab', count: 25 }, effect: { type: 'mult', target: 'alchemyLab', value: 2 }, purchased: false, icon: '‚öóÔ∏è' },
                alchemyLab50: { id: 'alchemyLab50', name: 'Elixir of Life', cost: 7500000000000, desc: 'Alchemy Labs are twice as efficient.', trigger: { building: 'alchemyLab', count: 50 }, effect: { type: 'mult', target: 'alchemyLab', value: 2 }, purchased: false, icon: '‚öóÔ∏è' },
                alchemyLab100: { id: 'alchemyLab100', name: 'Quantum Alchemy', cost: 37500000000000, desc: 'Alchemy Labs are twice as efficient.', trigger: { building: 'alchemyLab', count: 100 }, effect: { type: 'mult', target: 'alchemyLab', value: 2 }, purchased: false, icon: '‚öóÔ∏è' },
                alchemyLab250: { id: 'alchemyLab250', name: 'Multiversal Synthesis', cost: 187500000000000, desc: 'Alchemy Labs are twice as efficient.', trigger: { building: 'alchemyLab', count: 250 }, effect: { type: 'mult', target: 'alchemyLab', value: 2 }, purchased: false, icon: '‚öóÔ∏è' },
                alchemyLab500: { id: 'alchemyLab500', name: 'Infinite Transmutation', cost: 375000000000000, desc: 'Alchemy Labs are twice as efficient.', trigger: { building: 'alchemyLab', count: 500 }, effect: { type: 'mult', target: 'alchemyLab', value: 2 }, purchased: false, icon: '‚öóÔ∏è' },
                alchemyLab750: { id: 'alchemyLab750', name: 'Godlike Alchemy', cost: 562500000000000, desc: 'Alchemy Labs are twice as efficient.', trigger: { building: 'alchemyLab', count: 750 }, effect: { type: 'mult', target: 'alchemyLab', value: 2 }, purchased: false, icon: '‚öóÔ∏è' },
                alchemyLab1000: { id: 'alchemyLab1000', name: 'Alchemical Supremacy', cost: 750000000000000, desc: 'Alchemy Labs are twice as efficient.', trigger: { building: 'alchemyLab', count: 1000 }, effect: { type: 'mult', target: 'alchemyLab', value: 2 }, purchased: false, icon: '‚öóÔ∏è' },

                // Portal Tech Upgrades
                portal10: { id: 'portal10', name: 'Dimensional Anchors', cost: 10000000000000, desc: 'Portals are twice as efficient.', trigger: { building: 'portal', count: 10 }, effect: { type: 'mult', target: 'portal', value: 2 }, purchased: false, icon: 'üåÄ' },
                portal25: { id: 'portal25', name: 'Parallel Universes', cost: 50000000000000, desc: 'Portals are twice as efficient.', trigger: { building: 'portal', count: 25 }, effect: { type: 'mult', target: 'portal', value: 2 }, purchased: false, icon: 'üåÄ' },
                portal50: { id: 'portal50', name: 'Quantum Gates', cost: 100000000000000, desc: 'Portals are twice as efficient.', trigger: { building: 'portal', count: 50 }, effect: { type: 'mult', target: 'portal', value: 2 }, purchased: false, icon: 'üåÄ' },
                portal100: { id: 'portal100', name: 'Multiversal Bridges', cost: 500000000000000, desc: 'Portals are twice as efficient.', trigger: { building: 'portal', count: 100 }, effect: { type: 'mult', target: 'portal', value: 2 }, purchased: false, icon: 'üåÄ' },
                portal250: { id: 'portal250', name: 'Infinite Dimensions', cost: 2500000000000000, desc: 'Portals are twice as efficient.', trigger: { building: 'portal', count: 250 }, effect: { type: 'mult', target: 'portal', value: 2 }, purchased: false, icon: 'üåÄ' },
                portal500: { id: 'portal500', name: 'Reality Warping', cost: 5000000000000000, desc: 'Portals are twice as efficient.', trigger: { building: 'portal', count: 500 }, effect: { type: 'mult', target: 'portal', value: 2 }, purchased: false, icon: 'üåÄ' },
                portal750: { id: 'portal750', name: 'Omni-Dimensional Access', cost: 7500000000000000, desc: 'Portals are twice as efficient.', trigger: { building: 'portal', count: 750 }, effect: { type: 'mult', target: 'portal', value: 2 }, purchased: false, icon: 'üåÄ' },
                portal1000: { id: 'portal1000', name: 'Portal Supremacy', cost: 10000000000000000, desc: 'Portals are twice as efficient.', trigger: { building: 'portal', count: 1000 }, effect: { type: 'mult', target: 'portal', value: 2 }, purchased: false, icon: 'üåÄ' },

                // Time Machine Tech Upgrades
                timeMachine10: { id: 'timeMachine10', name: 'Temporal Accelerators', cost: 140000000000000, desc: 'Time Machines are twice as efficient.', trigger: { building: 'timeMachine', count: 10 }, effect: { type: 'mult', target: 'timeMachine', value: 2 }, purchased: false, icon: '‚è≥' },
                timeMachine25: { id: 'timeMachine25', name: 'Chronal Loops', cost: 700000000000000, desc: 'Time Machines are twice as efficient.', trigger: { building: 'timeMachine', count: 25 }, effect: { type: 'mult', target: 'timeMachine', value: 2 }, purchased: false, icon: '‚è≥' },
                timeMachine50: { id: 'timeMachine50', name: 'Paradox Engines', cost: 1400000000000000, desc: 'Time Machines are twice as efficient.', trigger: { building: 'timeMachine', count: 50 }, effect: { type: 'mult', target: 'timeMachine', value: 2 }, purchased: false, icon: '‚è≥' },
                timeMachine100: { id: 'timeMachine100', name: 'Multiversal Time Travel', cost: 7000000000000000, desc: 'Time Machines are twice as efficient.', trigger: { building: 'timeMachine', count: 100 }, effect: { type: 'mult', target: 'timeMachine', value: 2 }, purchased: false, icon: '‚è≥' },
                timeMachine250: { id: 'timeMachine250', name: 'Infinite Timelines', cost: 35000000000000000, desc: 'Time Machines are twice as efficient.', trigger: { building: 'timeMachine', count: 250 }, effect: { type: 'mult', target: 'timeMachine', value: 2 }, purchased: false, icon: '‚è≥' },
                timeMachine500: { id: 'timeMachine500', name: 'Reality Rewriting', cost: 70000000000000000, desc: 'Time Machines are twice as efficient.', trigger: { building: 'timeMachine', count: 500 }, effect: { type: 'mult', target: 'timeMachine', value: 2 }, purchased: false, icon: '‚è≥' },
                timeMachine750: { id: 'timeMachine750', name: 'Temporal Supremacy', cost: 105000000000000000, desc: 'Time Machines are twice as efficient.', trigger: { building: 'timeMachine', count: 750 }, effect: { type: 'mult', target: 'timeMachine', value: 2 }, purchased: false, icon: '‚è≥' },
                timeMachine1000: { id: 'timeMachine1000', name: 'Time Lord Mastery', cost: 140000000000000000, desc: 'Time Machines are twice as efficient.', trigger: { building: 'timeMachine', count: 1000 }, effect: { type: 'mult', target: 'timeMachine', value: 2 }, purchased: false, icon: '‚è≥' }
            },
            metaUpgrades: {
                analytics: {
                    id: 'analytics',
                    name: 'Analytics',
                    count: 0,
                    icon: 'üìä',
                    levels: [
                        { cost: 50, desc: 'Unlocks statistics (History: 0)' },
                        { cost: 100, desc: 'Unlocks Chart: Cookies (History: 100)' },
                        { cost: 1000, desc: 'Unlocks Chart: CPS (History: 200)' },
                        { cost: 2000, desc: 'Shows Efficiency (CPS/Cost) (History: 400)' },
                        { cost: 5000, desc: 'Shows Time-to-Wait (History: 800)' },
                        { cost: 7500, desc: 'Unlocks Chart: Upgrades (History: 1200)' },
                        { cost: 15000, desc: 'Extended History (History: 3000)' },
                        { cost: 25000, desc: 'Unlocks Chart: Accuracy % (History: 5000)' }
                    ]
                },
                autoBuyer: {
                    id: 'autoBuyer',
                    name: 'Auto Buyer',
                    count: 0,
                    icon: 'ü§ñ',
                    levels: [
                        { cost: 10000, desc: 'Auto-buys cheapest every 5s' },
                        { cost: 100000, desc: 'Auto-buys cheapest every 1s' },
                        { cost: 500000, desc: 'Auto-buys cheapest every 0.5s' },
                        { cost: 1000000, desc: 'Auto-buys most efficient every 1s' }
                    ]
                },
                clickFrenzy: {
                    id: 'clickFrenzy',
                    name: 'Click Frenzy',
                    count: 0,
                    icon: 'üî•',
                    levels: [
                        { cost: 100, desc: 'Unlocks Heat Meter (x2 Clicks at Max)' },
                        { cost: 250, desc: 'Heat decays 50% slower, +1 cookie per click above 50% heat' },
                        { cost: 500, desc: 'x5 Click Power at Max Heat' },
                        { cost: 2500, desc: 'Quick Ignition: +15 heat per click' },
                        { cost: 10000, desc: 'Inferno Mode: +10% CPS at Max Heat' },
                        { cost: 50000, desc: 'Chain Reaction: Clicks sustain heat at max' },
                        { cost: 250000, desc: 'Blazing Strikes: +5 cookies per click at Max Heat' },
                        { cost: 1000000, desc: 'Momentum: CPS multiplier grows with clicking speed at max heat' },
                        { cost: 5000000, desc: 'Accelerated Momentum: Momentum builds 2x faster' },
                        { cost: 25000000, desc: 'Turbo Momentum: Momentum builds 3x faster' },
                        { cost: 100000000, desc: 'Hyper Momentum: Momentum builds 4x faster' },
                        { cost: 500000000, desc: 'Ultimate Momentum: Momentum builds 5x faster' }
                    ]
                },
                timeWarp: {
                    id: 'timeWarp',
                    name: 'Time Warp',
                    count: 0,
                    icon: '‚è≥',
                    levels: [
                        { cost: 1000, desc: '10% Offline Earnings (Max 1hr)' },
                        { cost: 5000, desc: '25% Offline Earnings (Max 4hr)' },
                        { cost: 25000, desc: '50% Offline Earnings (Max 24hr)' }
                    ]
                },
                luckyClover: {
                    id: 'luckyClover',
                    name: 'Lucky Clover',
                    count: 0,
                    icon: 'üçÄ',
                    levels: [
                        { cost: 5000, desc: 'Golden Cookies spawn (100,000 cookie reward)' },
                        { cost: 25000, desc: 'Double Reward (200,000 cookies)' },
                        { cost: 100000, desc: 'Double Spawn Rate' },
                        { cost: 500000, desc: 'Triple Reward (500,000 cookies)' },
                        { cost: 2500000, desc: 'Quadruple Spawn Rate' },
                        { cost: 10000000, desc: '1 Million Reward' }
                    ]
                },
                goldenNet: {
                    id: 'goldenNet',
                    name: 'Golden Net',
                    count: 0,
                    icon: 'üï∏Ô∏è',
                    levels: [
                        { cost: 100000, desc: 'Auto-clicks Golden Cookies (5s delay)' },
                        { cost: 500000, desc: 'Auto-clicks Golden Cookies (2s delay)' },
                        { cost: 2500000, desc: 'Instant Auto-click (0.1s delay)' }
                    ]
                },
                infernalMomentum: {
                    id: 'infernalMomentum',
                    name: 'Infernal Momentum',
                    count: 0,
                    icon: 'üå™Ô∏è',
                    levels: [
                        { cost: 2000000, desc: 'Max Click Frenzy Momentum Cap: 3x ‚Üí 6x' },
                        { cost: 10000000, desc: 'Max Click Frenzy Momentum Cap: 6x ‚Üí 12x' },
                        { cost: 50000000, desc: 'Max Click Frenzy Momentum Cap: 12x ‚Üí 24x' },
                        { cost: 250000000, desc: 'Max Click Frenzy Momentum Cap: 24x ‚Üí 48x' },
                        { cost: 1000000000, desc: 'Max Click Frenzy Momentum Cap: 48x ‚Üí 96x' },
                        { cost: 5000000000, desc: 'Max Click Frenzy Momentum Cap: 96x ‚Üí 192x' },
                        { cost: 25000000000, desc: 'Max Click Frenzy Momentum Cap: 192x ‚Üí 384x' },
                        { cost: 100000000000, desc: 'Max Click Frenzy Momentum Cap: 384x ‚Üí 768x' }
                    ]
                },
                needForSpeed: {
                    id: 'needForSpeed',
                    name: 'Need for Speed',
                    count: 0,
                    icon: 'üèéÔ∏è',
                    levels: [
                        { cost: 1000, desc: 'Spacebar hotkey on desktop, +2 cookies per click on mobile' }
                    ]
                },
                autoClicker: {
                    id: 'autoClicker',
                    name: 'Auto Clicker',
                    count: 0,
                    icon: 'ü§ñ',
                    levels: [
                        { cost: 5000, desc: 'Auto-clicks every 10 seconds' },
                        { cost: 10000, desc: 'Auto-clicks every 7.5 seconds' },
                        { cost: 25000, desc: 'Auto-clicks every 5 seconds' },
                        { cost: 50000, desc: 'Auto-clicks every 2.5 seconds' },
                        { cost: 100000, desc: 'Auto-clicks every 2 seconds' },
                        { cost: 250000, desc: 'Auto-clicks every 1 seconds' },
                        { cost: 500000, desc: 'Auto-clicks every .75 seconds' },
                        { cost: 1000000, desc: 'Auto-clicks every 0.5 seconds' },
                        { cost: 2500000, desc: 'Auto-clicks every 0.25 seconds' },
                        { cost: 5000000, desc: 'Auto-clicks ten times per second' }
                    ]
                },
                autoClickPrecision: {
                    id: 'autoClickPrecision',
                    name: 'Auto Click Precision',
                    count: 0,
                    icon: 'üéØ',
                    levels: [
                        { cost: 200000000, desc: 'Reduces click inaccuracy by 20%' },
                        { cost: 1000000000, desc: 'Reduces click inaccuracy by 40%' },
                        { cost: 5000000000, desc: 'Reduces click inaccuracy by 60%' },
                        { cost: 25000000000, desc: 'Reduces click inaccuracy by 80%' },
                        { cost: 100000000000, desc: 'Perfect accuracy below 50x momentum' },
                        { cost: 500000000000, desc: 'Perfect accuracy below 100x momentum' },
                        { cost: 2500000000000, desc: 'Perfect accuracy below 200x momentum' },
                        { cost: 10000000000000, desc: 'Perfect accuracy below 400x momentum' },
                        { cost: 50000000000000, desc: 'Perfect accuracy at all momentum levels' }
                    ]
                }
            },
            stats: {
                totalCookies: 0,
                totalClicks: 0,
                startTime: Date.now(),
                lastSaveTime: Date.now(),
                history: [] // { timestamp, cookies, cps, upgrades }
            },
            settings: {
                autoBuyerMode: 'off', // 'off', 'cheapest', 'efficient'
                autoClickerMode: 'on', // 'off', 'on'
                techEverUnlocked: false,
                metaEverUnlocked: false
            }
        };

        // Auto Clicker intervals in milliseconds for each level (1-10)
        const autoClickerIntervals = [10000, 7500, 5000, 2500, 2000, 1000, 750, 500, 250, 100];

        // Fix: Deep copy defaultState to avoid mutation
        let state = JSON.parse(JSON.stringify(defaultState));
        // Ensure settings exist if loading from old save
        if (!state.settings) state.settings = { autoBuyerMode: 'off', autoClickerMode: 'on' };
        // Ensure tech exists if loading from old save
        if (!state.tech) state.tech = JSON.parse(JSON.stringify(defaultState.tech));
        // Ensure new buildings exist
        Object.keys(defaultState.upgrades).forEach(key => {
            if (!state.upgrades[key]) state.upgrades[key] = { ...defaultState.upgrades[key] };
        });
        let heat = 0;
        let heatDecayRate = 0.5;
        let isResetting = false; // Flag to prevent save on reset

        // Click tracking for CPS display
        let clickTimestamps = []; // Array of click timestamps
        let maxClicksPerSecond = 0; // Max clicks per second in last 60s

        // Momentum tracking (Level 8)
        let momentumMultiplier = 1.0; // CPS multiplier from momentum
        let timeAtMaxHeat = 0; // Time spent at max heat in seconds

        // Auto Clicker
        let autoClickerInterval = null;

        // Click Precision Tracking
        let lastClickWasMiss = false;
        let totalMissedClicks = 0;
        let totalAutoClicks = 0; // Track total auto clicks separately

        // DOM Elements
        const scoreEl = document.getElementById('score');
        const cpsEl = document.getElementById('cps-display');
        const cookieBtn = document.getElementById('cookieBtn');
        const upgradesList = document.getElementById('upgrades-list');
        const techList = document.getElementById('tech-list');
        const metaList = document.getElementById('meta-list');
        const tabStructures = document.getElementById('tab-structures');
        const tabTech = document.getElementById('tab-tech');
        const tabMeta = document.getElementById('tab-meta');
        const resetBtn = document.getElementById('resetBtn');
        const statsBtn = document.getElementById('statsBtn');
        const cookieVisual = document.getElementById('cookieVisual');
        const tooltip = document.getElementById('tooltip');
        const statsModal = document.getElementById('statsModal');
        const closeStats = document.getElementById('closeStats');
        const statsContent = document.getElementById('statsContent');
        const statsText = document.getElementById('statsText');
        const statsChartContainer = document.getElementById('statsChartContainer');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettings = document.getElementById('closeSettings');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const importFile = document.getElementById('importFile');
        const heatContainer = document.getElementById('heat-container');
        const heatBar = document.getElementById('heat-bar');
        const heatText = document.querySelector('.heat-text');
        const maxCpsDisplay = document.getElementById('max-cps-display');
        const maxCpsValue = document.getElementById('max-cps-value');

        // Helper: Format Numbers
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
            // if (num >= 1000) return (num / 1000).toFixed(1) + 'k'; // User requested no 4-digit truncation
            return Math.floor(num).toLocaleString(); // Add commas for readability
        }

        // Helper: Format CPS (allows decimals)
        function formatCPS(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
            return num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 1 });
        }

        // Helper: Calculate Cost
        function getCost(upgradeId) {
            const u = state.upgrades[upgradeId];
            return Math.floor(u.baseCost * Math.pow(1.15, u.count));
        }

        // Helper: Calculate Total CPS
        function getCPS() {
            let cps = 0;

            // Refined CPS Calculation
            Object.values(state.upgrades).forEach(u => {
                let buildingCPS = u.cps * u.count;

                // Apply Tech Multipliers for this building
                let multiplier = 1;
                Object.values(state.tech).forEach(t => {
                    if (t.purchased && t.effect.type === 'mult' && t.effect.target === u.id) {
                        multiplier *= t.effect.value;
                    }
                });

                cps += buildingCPS * multiplier;
            });

            // Level 5: Inferno Mode - +10% CPS at Max Heat
            if (state.metaUpgrades.clickFrenzy.count >= 5 && heat >= 100) {
                cps *= 1.10;
            }

            // Level 8: Momentum - Apply momentum multiplier
            if (state.metaUpgrades.clickFrenzy.count >= 8) {
                cps *= momentumMultiplier;
            }

            return cps;
        }

        // Initialization
        function init() {
            loadGame();
            generateChips();
            createUpgradesList(); // Create DOM once
            createTechList(); // Create DOM once for tech
            createMetaList();
            updateUI(); // Initial UI update
            requestAnimationFrame(gameLoop);

            // Auto-save every 30 seconds
            setInterval(saveGame, 30000);

            // Auto-Buyer Loop (1s tick, logic handles throttling)
            setInterval(runAutoBuyer, 1000);

            // Heat Decay Loop (100ms)
            setInterval(updateHeat, 100);

            // Golden Cookie Loop (Check every 1s)
            setInterval(trySpawnGoldenCookie, 1000);

            // Check Offline Earnings
            checkOfflineEarnings();

            // Analytics Data Recording (Every 5s)
            setInterval(recordAnalyticsData, 5000);

            // Fix: Save on exit
            window.addEventListener('beforeunload', saveGame);

            // Event Listeners
            closeStats.addEventListener('click', closeStatsModal);
            statsBtn.addEventListener('click', showStats);
            statsModal.addEventListener('click', (e) => {
                if (e.target === statsModal) closeStatsModal();
            });

            // Spacebar hotkey for Need for Speed
            document.addEventListener('keydown', (e) => {
                if (e.key === ' ' && state.metaUpgrades.needForSpeed.count > 0 && !('ontouchstart' in window)) {
                    e.preventDefault();
                    console.log("Spacebar pressed - triggering click");
                    const rect = cookieBtn.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    performClick(centerX, centerY);
                }
            });

            // Tabs
            // Tabs
            tabStructures.addEventListener('click', () => switchTab('structures'));
            tabTech.addEventListener('click', () => switchTab('tech'));
            tabMeta.addEventListener('click', () => switchTab('meta'));

            // Settings
            settingsBtn.addEventListener('click', () => settingsModal.classList.add('active'));
            closeSettings.addEventListener('click', () => settingsModal.classList.remove('active'));
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) settingsModal.classList.remove('active');
            });

            resetBtn.addEventListener('click', () => {
                if (confirm("Are you sure you want to wipe your save?")) {
                    isResetting = true; // Prevent other saves

                    // Clear auto clicker interval
                    if (autoClickerInterval) {
                        clearInterval(autoClickerInterval);
                        autoClickerInterval = null;
                    }

                    // Preserve lifetime stats before reset
                    const lifetimeStats = {
                        totalCookies: state.stats.totalCookies,
                        totalClicks: state.stats.totalClicks,
                        startTime: state.stats.startTime
                    };

                    // Explicitly overwrite with default state
                    state = JSON.parse(JSON.stringify(defaultState));
                    // Explicitly reset upgrade counts
                    Object.keys(state.upgrades).forEach(key => {
                        state.upgrades[key].count = 0;
                    });
                    // Explicitly reset meta upgrades
                    if (state.metaUpgrades) {
                        Object.keys(state.metaUpgrades).forEach(key => {
                            state.metaUpgrades[key].count = 0;
                        });
                    }
                    // Explicitly reset tech
                    if (state.tech) {
                        Object.keys(state.tech).forEach(key => {
                            state.tech[key].purchased = false;
                        });
                    }
                    // Reset stats but preserve lifetime stats
                    state.stats = {
                        totalCookies: lifetimeStats.totalCookies,
                        totalClicks: lifetimeStats.totalClicks,
                        startTime: lifetimeStats.startTime,
                        lastSaveTime: Date.now(),
                        history: []
                    };
                    // Save the empty state immediately
                    localStorage.setItem('cosmicClickerSave', JSON.stringify(state));
                    // Force reload
                    location.reload();
                }
            });

            // Export Save
            exportBtn.addEventListener('click', () => {
                const data = JSON.stringify(state);
                const blob = new Blob([data], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cosmic_clicker_save_${Date.now()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            });

            // Import Save
            importBtn.addEventListener('click', () => importFile.click());

            importFile.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        // Basic validation
                        if (data.score !== undefined && data.upgrades) {
                            isResetting = true; // Prevent overwrite during reload
                            localStorage.setItem('cosmicClickerSave', JSON.stringify(data));
                            location.reload();
                        } else {
                            alert("Invalid save file!");
                        }
                    } catch (err) {
                        alert("Error reading save file!");
                        console.error(err);
                    }
                };
                reader.readAsText(file);
            });
        }

        // Generate visual chips on the cookie
        function generateChips() {
            for (let i = 0; i < 8; i++) {
                const chip = document.createElement('div');
                chip.classList.add('chip');
                const size = Math.random() * 20 + 15;
                chip.style.width = `${size}px`;
                chip.style.height = `${size}px`;
                chip.style.top = `${Math.random() * 70 + 10}%`;
                chip.style.left = `${Math.random() * 70 + 10}%`;
                chip.style.transform = `rotate(${Math.random() * 360}deg)`;
                cookieVisual.appendChild(chip);
            }
        }

        // Fix: Create Upgrades List (Run once)
        function createUpgradesList() {
            upgradesList.innerHTML = '';
            Object.values(state.upgrades).forEach(u => {
                const item = document.createElement('div');
                item.className = 'upgrade-item';
                item.id = `upgrade-${u.id}`;
                item.onclick = () => buyUpgrade(u.id);

                // Tooltip Events
                item.onmouseenter = (e) => showTooltip(u.id, e.clientX, e.clientY);
                item.onmousemove = (e) => moveTooltip(e.clientX, e.clientY);
                item.onmouseleave = hideTooltip;

                item.innerHTML = `
                    <div class="upgrade-icon">${u.icon}</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">${u.name}</div>
                        <div class="upgrade-cost">üç™ ${formatNumber(getCost(u.id))}</div>
                    </div>
                    <div class="upgrade-count">${u.count}</div>
                `;
                item.setAttribute('aria-label', `Buy ${u.name}, costs ${formatNumber(getCost(u.id))} cookies, owned: ${u.count}`);
                upgradesList.appendChild(item);
            });
        }

        // Tabs Logic
        // Tabs Logic
        function switchTab(tab) {
            // Reset all
            upgradesList.style.display = 'none';
            techList.style.display = 'none';
            metaList.style.display = 'none';
            tabStructures.classList.remove('active');
            tabTech.classList.remove('active');
            tabMeta.classList.remove('active');

            if (tab === 'structures') {
                upgradesList.style.display = 'block';
                tabStructures.classList.add('active');
            } else if (tab === 'tech') {
                techList.style.display = 'block';
                tabTech.classList.add('active');
            } else if (tab === 'meta') {
                metaList.style.display = 'block';
                tabMeta.classList.add('active');
            }
        }

        // Tech Logic
        function createTechList() {
            techList.innerHTML = '';
            Object.values(state.tech).forEach(t => {
                const item = document.createElement('div');
                item.className = 'tech-item';
                item.id = `tech-${t.id}`;
                item.onclick = () => buyTech(t.id);

                // Initially hidden until unlocked
                item.style.display = 'none';

                item.innerHTML = `
                    <div class="tech-icon">${t.icon}</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">${t.name}</div>
                        <div class="upgrade-cost">üç™ ${formatNumber(t.cost)}</div>
                    </div>
                `;
                item.setAttribute('aria-label', `Buy ${t.name}, ${t.desc}, costs ${formatNumber(t.cost)} cookies`);

                // Tooltip
                item.onmouseenter = (e) => {
                    tooltip.innerHTML = `
                        <div class="tooltip-header">${t.name}</div>
                        <div class="tooltip-stat">${t.desc}</div>
                        <div class="tooltip-stat">Cost: <span>üç™ ${formatNumber(t.cost)}</span></div>
                    `;
                    tooltip.style.display = 'block';
                    moveTooltip(e.clientX, e.clientY);
                };
                item.onmousemove = (e) => moveTooltip(e.clientX, e.clientY);
                item.onmouseleave = hideTooltip;

                techList.appendChild(item);
            });
        }

        function updateTechVisuals() {
            Object.values(state.tech).forEach(t => {
                const item = document.getElementById(`tech-${t.id}`);
                if (!item) return;

                // Check Trigger
                const triggerBuilding = state.upgrades[t.trigger.building];
                const isUnlocked = triggerBuilding && triggerBuilding.count >= t.trigger.count;

                if (t.purchased) {
                    item.classList.add('purchased'); // CSS hides it
                } else if (isUnlocked) {
                    item.style.display = 'flex';

                    if (state.score >= t.cost) {
                        item.classList.remove('disabled');
                    } else {
                        item.classList.add('disabled');
                    }
                } else {
                    item.style.display = 'none';
                }
            });
        }

        function buyTech(techId) {
            const t = state.tech[techId];
            if (t.purchased) return;
            if (state.score >= t.cost) {
                state.score -= t.cost;
                t.purchased = true;
                updateTechVisuals();
                updateUI();
                saveGame();
            }
        }

        // Create Meta List
        function createMetaList() {
            metaList.innerHTML = '';
            const sortedMeta = Object.values(state.metaUpgrades).sort((a, b) => a.levels[0].cost - b.levels[0].cost);
            sortedMeta.forEach(u => {
                const item = document.createElement('div');
                item.className = 'upgrade-item';
                item.id = `meta-${u.id}`;
                item.onclick = () => buyMetaUpgrade(u.id);

                // Determine current level info
                const currentLevel = u.count;
                const nextLevel = u.levels[currentLevel];
                const isMaxed = currentLevel >= u.levels.length;

                const costText = isMaxed ? "Maxed" : `üç™ ${formatNumber(nextLevel.cost)}`;
                const descText = isMaxed ? "Max Level Reached" : nextLevel.desc;
                const levelText = isMaxed ? `Lvl ${currentLevel}` : `Lvl ${currentLevel} ‚Üí ${currentLevel + 1}`;

                let toggleHtml = '';
                if (u.id === 'autoBuyer' && currentLevel > 0) {
                    const mode = state.settings.autoBuyerMode || 'off';
                    let modeColor = '#ef4444'; // Red for OFF
                    if (mode === 'cheapest') modeColor = '#22c55e'; // Green for CHEAPEST
                    if (mode === 'efficient') modeColor = '#3b82f6'; // Blue for EFFICIENT

                    toggleHtml = `
                        <div class="toggle-container" onclick="event.stopPropagation()">
                            <button id="autoBuyerBtn" class="tab-btn" aria-label="Toggle auto buyer mode, current mode: ${mode}" style="background: rgba(255,255,255,0.1); border-color: ${modeColor}; color: ${modeColor}; font-size: 0.8rem; padding: 0.2rem 0.5rem;">
                                Mode: ${mode.toUpperCase()}
                            </button>
                        </div>
                    `;
                }
                if (u.id === 'autoClicker' && currentLevel > 0) {
                    const mode = state.settings.autoClickerMode || 'on';
                    let modeColor = '#ef4444'; // Red for OFF
                    if (mode === 'on') modeColor = '#22c55e'; // Green for ON

                    toggleHtml = `
                        <div class="toggle-container" onclick="event.stopPropagation()">
                            <button id="autoClickerBtn" class="tab-btn" aria-label="Toggle auto clicker mode, current mode: ${mode}" style="background: rgba(255,255,255,0.1); border-color: ${modeColor}; color: ${modeColor}; font-size: 0.8rem; padding: 0.2rem 0.5rem;">
                                Mode: ${mode.toUpperCase()}
                            </button>
                        </div>
                    `;
                }

                item.innerHTML = `
                    <div class="upgrade-icon">${u.icon}</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">${u.name} <span style="font-size: 0.8em; opacity: 0.7;">${levelText}</span></div>
                        <div class="upgrade-cost">${costText}</div>
                        ${toggleHtml}
                    </div>
                `;
                item.setAttribute('aria-label', `${u.name}, ${levelText}, ${isMaxed ? 'maxed out' : descText + ', costs ' + formatNumber(nextLevel.cost) + ' cookies'}`);

                // Tooltip for Meta
                item.onmouseenter = (e) => {
                    tooltip.innerHTML = `
                        <div class="tooltip-header">${u.name}</div>
                        <div class="tooltip-stat">${descText}</div>
                        ${!isMaxed ? `<div class="tooltip-stat">Cost: <span>üç™ ${formatNumber(nextLevel.cost)}</span></div>` : ''}
                    `;
                    tooltip.style.display = 'block';
                    moveTooltip(e.clientX, e.clientY);
                };
                item.onmousemove = (e) => moveTooltip(e.clientX, e.clientY);
                item.onmouseleave = hideTooltip;

                metaList.appendChild(item);

                // Add Toggle Listener
                if (u.id === 'autoBuyer' && currentLevel > 0) {
                    const btn = document.getElementById('autoBuyerBtn');
                    if (btn) {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            cycleAutoBuyerMode();
                        });
                    }
                }
                if (u.id === 'autoClicker' && currentLevel > 0) {
                    const btn = document.getElementById('autoClickerBtn');
                    if (btn) {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            cycleAutoClickerMode();
                        });
                    }
                }
            });
        }

        // Fix: Update Upgrade Visuals (Enable/Disable)
        function updateUpgradeVisuals() {
            // Standard Upgrades
            const upgradeOrder = ['cursor', 'grandma', 'farm', 'mine', 'factory', 'bank', 'temple', 'wizardTower', 'shipment', 'alchemyLab', 'portal', 'timeMachine'];

            upgradeOrder.forEach((id, index) => {
                const u = state.upgrades[id];
                const el = document.getElementById(`upgrade-${u.id}`);
                if (!el) return;

                // Visibility Logic
                let isVisible = false;
                if (index === 0) {
                    isVisible = true; // First item always visible
                } else {
                    const prevId = upgradeOrder[index - 1];
                    if (state.upgrades[prevId].count > 0) {
                        isVisible = true;
                    }
                }

                if (isVisible) {
                    el.style.display = 'flex';
                } else {
                    el.style.display = 'none';
                }

                const cost = getCost(u.id);
                if (state.score >= cost) {
                    el.classList.remove('disabled');
                } else {
                    el.classList.add('disabled');
                }
                // Update cost text dynamically
                el.querySelector('.upgrade-cost').textContent = `üç™ ${formatNumber(cost)}`;
                el.querySelector('.upgrade-count').textContent = u.count;
            });

            // Meta Upgrades
            Object.values(state.metaUpgrades).forEach(u => {
                const el = document.getElementById(`meta-${u.id}`);
                const currentLevel = u.count;
                const isMaxed = currentLevel >= u.levels.length;

                // Special unlock condition for Need for Speed
                if (u.id === 'needForSpeed' && getCPS() < 100) {
                    el.style.display = 'none';
                    return;
                }

                // Special unlock condition for Auto Clicker
                if (u.id === 'autoClicker' && state.stats.totalClicks < 500) {
                    el.style.display = 'none';
                    return;
                }

                // Special unlock condition for Click Frenzy levels 9+
                if (u.id === 'clickFrenzy' && !isMaxed && currentLevel + 1 > 8 && state.metaUpgrades.infernalMomentum.count < 4) {
                    el.style.display = 'none';
                    return;
                }

                // Special unlock condition for Analytics level 8
                if (u.id === 'analytics' && !isMaxed && currentLevel + 1 > 7 && totalMissedClicks === 0) {
                    el.style.display = 'none';
                    return;
                }

                if (isMaxed) {
                    el.classList.add('disabled');
                    el.querySelector('.upgrade-cost').textContent = "Maxed";
                    el.querySelector('.upgrade-name span').textContent = `Lvl ${currentLevel}`;
                    el.style.opacity = 0.5;
                } else {
                    const nextCost = u.levels[currentLevel].cost;
                    el.querySelector('.upgrade-cost').textContent = `üç™ ${formatNumber(nextCost)}`;

                    el.querySelector('.upgrade-name span').textContent = `Lvl ${currentLevel} ‚Üí ${currentLevel + 1}`;

                    if (state.score >= nextCost) {
                        el.classList.remove('disabled');
                    } else {
                        el.classList.add('disabled');
                    }
                }
            });
            // Stats Button Visibility
            if (state.metaUpgrades.analytics.count > 0) {
                statsBtn.style.display = 'block';
            }
        }

        // Core Logic: Click Cookie
        function performClick(x, y, isAutoClick = false) {
            // Check if click hits the cookie
            const rect = cookieBtn.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const radius = rect.width / 2;
            
            // Calculate distance from center
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate inaccuracy based on heat and momentum
            let inaccuracyFactor = 0;
            if (state.metaUpgrades.clickFrenzy.count >= 8 && (heat >= 100 || momentumMultiplier > 1.5)) {
                // Base inaccuracy increases with momentum and time at max heat
                const momentumInaccuracy = (momentumMultiplier - 1) * 0.3; // 30% per momentum level
                const heatInaccuracy = (heat / 150) * 0.2; // Up to 20% from heat
                inaccuracyFactor = momentumInaccuracy + heatInaccuracy;
                
                // Add speed-based inaccuracy from auto clicker
                if (state.metaUpgrades.autoClicker.count > 0) {
                    const clickerLevel = state.metaUpgrades.autoClicker.count;
                    const interval = autoClickerIntervals[clickerLevel - 1];
                    
                    // Speed multiplier: increases dramatically below 1000ms
                    let speedMultiplier = 1.0;
                    if (interval <= 1000) {
                        // Below 1000ms: exponential increase
                        // 1000ms = 2x, 750ms = 3x, 500ms = 5x, 250ms = 9x, 100ms = 15x
                        speedMultiplier = 1 + (1000 - interval) / 100;
                    } else {
                        // Above 1000ms: minimal scaling
                        speedMultiplier = 1.0 + (10000 - interval) / 50000;
                    }
                    
                    inaccuracyFactor *= speedMultiplier;
                }
                
                // Apply precision upgrades to reduce inaccuracy
                const precisionLevel = state.metaUpgrades.autoClickPrecision.count;
                if (precisionLevel >= 1) inaccuracyFactor *= 0.8; // -20%
                if (precisionLevel >= 2) inaccuracyFactor *= 0.75; // -40% total
                if (precisionLevel >= 3) inaccuracyFactor *= 0.67; // -60% total
                if (precisionLevel >= 4) inaccuracyFactor *= 0.5; // -80% total
                if (precisionLevel >= 5 && momentumMultiplier < 50) inaccuracyFactor = 0;
                if (precisionLevel >= 6 && momentumMultiplier < 100) inaccuracyFactor = 0;
                if (precisionLevel >= 7 && momentumMultiplier < 200) inaccuracyFactor = 0;
                if (precisionLevel >= 8 && momentumMultiplier < 400) inaccuracyFactor = 0;
                if (precisionLevel >= 9) inaccuracyFactor = 0; // Perfect accuracy always
            }
            
            // Check if click missed
            const missThreshold = radius * (1 + inaccuracyFactor);
            const clickMissed = distance > radius && isAutoClick;
            
            if (clickMissed) {
                // Show X for missed click
                lastClickWasMiss = true;
                totalMissedClicks++;
                totalAutoClicks++;
                spawnFloatingText(x, y, "‚ùå", Math.PI / 2, 1);
                createParticles(x, y, Math.PI / 2, 1);
                return; // Don't give cookies for missed clicks
            }
            
            // Count successful auto clicks
            if (isAutoClick) {
                totalAutoClicks++;
            }
            
            lastClickWasMiss = false;

            // Heat Logic
            if (state.metaUpgrades.clickFrenzy.count > 0) {
                const frenzyLevel = state.metaUpgrades.clickFrenzy.count;
                // Level 4: Quick Ignition - +15 heat per click instead of +10
                const heatGain = (frenzyLevel >= 4) ? 15 : 10;

                // Level 6: Chain Reaction - At max heat, clicks add +5 heat (sustaining)
                if (heat >= 100 && frenzyLevel >= 6) {
                    heat = Math.min(150, heat + 5);
                } else {
                    heat = Math.min(150, heat + heatGain);
                }
                updateHeatVisuals();
            }

            // Calculate Click Power
            let clickPower = 1;
            const frenzyLevel = state.metaUpgrades.clickFrenzy.count;

            // Level 2: +1 cookie per click above 50% heat
            if (frenzyLevel >= 2 && heat > 50) {
                clickPower += 1;
            }

            if (heat >= 100) {
                clickPower = (frenzyLevel >= 3) ? 5 : 2;

                // Level 7: Blazing Strikes - +5 cookies per click at max heat
                if (frenzyLevel >= 7) {
                    clickPower += 5;
                }
            }

            // Need for Speed mobile bonus
            if (state.metaUpgrades.needForSpeed.count > 0 && 'ontouchstart' in window) {
                clickPower += 2;
            }

            state.score += clickPower;
            state.totalClicks++; // Legacy counter
            state.stats.totalClicks++; // New stats counter
            state.stats.totalCookies += clickPower;

            // Track click for CPS calculation
            if (state.metaUpgrades.clickFrenzy.count > 0) {
                trackClick();
            }

            updateUI();

            // Calculate angle based on heat for both text and particles
            let clickAngle;
            if (heat <= 100) {
                // Always upward: from 45¬∞ to 135¬∞ (œÄ/4 to 3œÄ/4)
                const minAngle = Math.PI / 4;
                const maxAngle = 3 * Math.PI / 4;
                const spread = (heat / 100) * (maxAngle - minAngle);
                clickAngle = minAngle + Math.random() * spread;
            } else {
                // Rising vertically: from 20¬∞ to 160¬∞ (centered around 90¬∞ up)
                const minAngle = 20 * Math.PI / 180;
                const maxAngle = 160 * Math.PI / 180;
                clickAngle = minAngle + Math.random() * (maxAngle - minAngle);
            }

            const text = (clickPower > 1) ? `+${clickPower} üî•` : "+1";
            spawnFloatingText(x, y, text, clickAngle, momentumMultiplier);
            createParticles(x, y, clickAngle, momentumMultiplier);
        }

        cookieBtn.addEventListener('mousedown', (e) => {
            performClick(e.clientX, e.clientY);
        });

        // Core Logic: Buy Upgrade
        function buyUpgrade(id) {
            const cost = getCost(id);
            if (state.score >= cost) {
                state.score -= cost;
                state.upgrades[id].count++;
                updateUI();
                // Fix: Removed synchronous saveGame() for performance
            }
        }

        // Meta Logic: Buy Meta Upgrade
        function buyMetaUpgrade(id) {
            const u = state.metaUpgrades[id];
            const currentLevel = u.count;

            if (currentLevel < u.levels.length) {
                const cost = u.levels[currentLevel].cost;
                if (state.score >= cost) {
                    state.score -= cost;
                    u.count++;
                    // Update auto clicker interval if purchased
                    if (id === 'autoClicker') {
                        if (autoClickerInterval) {
                            clearInterval(autoClickerInterval);
                            autoClickerInterval = null;
                        }
                        if (state.settings.autoClickerMode === 'on') {
                            const interval = autoClickerIntervals[u.count - 1];
                            autoClickerInterval = setInterval(() => {
                                const rect = cookieBtn.getBoundingClientRect();
                                const centerX = rect.left + rect.width / 2;
                                const centerY = rect.top + rect.height / 2;
                                const radius = rect.width / 2;
                                
                                // Calculate inaccuracy
                                let offsetX = 0;
                                let offsetY = 0;
                                
                                if (state.metaUpgrades.clickFrenzy.count >= 8 && (heat >= 100 || momentumMultiplier > 1.5)) {
                                    const momentumInaccuracy = (momentumMultiplier - 1) * 0.3;
                                    const heatInaccuracy = (heat / 150) * 0.2;
                                    let inaccuracyFactor = momentumInaccuracy + heatInaccuracy;
                                    
                                    const precisionLevel = state.metaUpgrades.autoClickPrecision.count;
                                    if (precisionLevel >= 1) inaccuracyFactor *= 0.8;
                                    if (precisionLevel >= 2) inaccuracyFactor *= 0.75;
                                    if (precisionLevel >= 3) inaccuracyFactor *= 0.67;
                                    if (precisionLevel >= 4) inaccuracyFactor *= 0.5;
                                    if (precisionLevel >= 5 && momentumMultiplier < 50) inaccuracyFactor = 0;
                                    if (precisionLevel >= 6 && momentumMultiplier < 100) inaccuracyFactor = 0;
                                    if (precisionLevel >= 7 && momentumMultiplier < 200) inaccuracyFactor = 0;
                                    if (precisionLevel >= 8 && momentumMultiplier < 400) inaccuracyFactor = 0;
                                    if (precisionLevel >= 9) inaccuracyFactor = 0;
                                    
                                    const maxOffset = radius * inaccuracyFactor;
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = Math.random() * maxOffset;
                                    offsetX = Math.cos(angle) * distance;
                                    offsetY = Math.sin(angle) * distance;
                                }
                                
                                performClick(centerX + offsetX, centerY + offsetY, true);
                            }, interval);
                        }
                    }
                    updateUI();
                    createMetaList(); // Re-render to update next level info
                }
            }
        }

        // Auto Buyer Logic
        function cycleAutoBuyerMode() {
            const modes = ['off', 'cheapest'];
            if (state.metaUpgrades.autoBuyer.count >= 4) {
                modes.push('efficient');
            }

            let currentIdx = modes.indexOf(state.settings.autoBuyerMode);
            if (currentIdx === -1) currentIdx = 0;

            const nextIdx = (currentIdx + 1) % modes.length;
            state.settings.autoBuyerMode = modes[nextIdx];

            createMetaList(); // Re-render button
            saveGame();
        }

        function cycleAutoClickerMode() {
            const modes = ['off', 'on'];
            let currentIdx = modes.indexOf(state.settings.autoClickerMode);
            if (currentIdx === -1) currentIdx = 0;

            const nextIdx = (currentIdx + 1) % modes.length;
            state.settings.autoClickerMode = modes[nextIdx];

            // Start or stop auto clicker based on mode
            if (state.settings.autoClickerMode === 'on' && state.metaUpgrades.autoClicker.count > 0) {
                if (!autoClickerInterval) {
                    const interval = autoClickerIntervals[state.metaUpgrades.autoClicker.count - 1];
                    autoClickerInterval = setInterval(() => {
                        const rect = cookieBtn.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        const radius = rect.width / 2;
                        
                        let offsetX = 0;
                        let offsetY = 0;
                        
                        if (state.metaUpgrades.clickFrenzy.count >= 8 && (heat >= 100 || momentumMultiplier > 1.5)) {
                            const momentumInaccuracy = (momentumMultiplier - 1) * 0.3;
                            const heatInaccuracy = (heat / 150) * 0.2;
                            let inaccuracyFactor = momentumInaccuracy + heatInaccuracy;
                            
                            const precisionLevel = state.metaUpgrades.autoClickPrecision.count;
                            if (precisionLevel >= 1) inaccuracyFactor *= 0.8;
                            if (precisionLevel >= 2) inaccuracyFactor *= 0.75;
                            if (precisionLevel >= 3) inaccuracyFactor *= 0.67;
                            if (precisionLevel >= 4) inaccuracyFactor *= 0.5;
                            if (precisionLevel >= 5 && momentumMultiplier < 50) inaccuracyFactor = 0;
                            if (precisionLevel >= 6 && momentumMultiplier < 100) inaccuracyFactor = 0;
                            if (precisionLevel >= 7 && momentumMultiplier < 200) inaccuracyFactor = 0;
                            if (precisionLevel >= 8 && momentumMultiplier < 400) inaccuracyFactor = 0;
                            if (precisionLevel >= 9) inaccuracyFactor = 0;
                            
                            const maxOffset = radius * inaccuracyFactor;
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * maxOffset;
                            offsetX = Math.cos(angle) * distance;
                            offsetY = Math.sin(angle) * distance;
                        }
                        
                        performClick(centerX + offsetX, centerY + offsetY, true);
                    }, interval);
                }
            } else {
                if (autoClickerInterval) {
                    clearInterval(autoClickerInterval);
                    autoClickerInterval = null;
                }
            }

            createMetaList(); // Re-render button
            saveGame();
        }

        let autoBuyerTick = 0;
        function runAutoBuyer() {
            const mode = state.settings.autoBuyerMode;
            if (!mode || mode === 'off') return;

            const level = state.metaUpgrades.autoBuyer.count;
            if (level === 0) return;

            // Level 1: Every 3s (tick % 3 === 0)
            // Level 2: Every 1s
            // Level 3: Every 0.5s (runs twice per tick)

            autoBuyerTick++;
            if (level === 1 && autoBuyerTick % 3 !== 0) return;

            const iterations = (level >= 3 && mode === 'cheapest') ? 2 : 1;

            for (let i = 0; i < iterations; i++) {
                let targetId = null;

                if (mode === 'cheapest') {
                    // Cheapest Strategy
                    let minCost = Infinity;
                    Object.values(state.upgrades).forEach(u => {
                        const cost = getCost(u.id);
                        if (cost < minCost) {
                            minCost = cost;
                            targetId = u.id;
                        }
                    });
                    if (targetId && state.score < getCost(targetId)) targetId = null;
                } else if (mode === 'efficient' && level >= 4) {
                    // Smart Strategy (Best Efficiency - Only consider upgrades available in next 60s)
                    const upgradeOrder = ['cursor', 'grandma', 'farm', 'mine', 'factory', 'bank', 'temple', 'wizardTower', 'shipment', 'alchemyLab', 'portal', 'timeMachine'];
                    let maxEff = -1;
                    const currentCPS = getCPS();
                    const TIME_HORIZON = 60; // Only consider upgrades available in next 60 seconds

                    // Find the best efficiency among UNLOCKED upgrades available within 60s
                    upgradeOrder.forEach((id, index) => {
                        // Check unlock status
                        if (index > 0) {
                            const prevId = upgradeOrder[index - 1];
                            if (state.upgrades[prevId].count === 0) return; // Locked
                        }

                        const u = state.upgrades[id];
                        const cost = getCost(u.id);

                        // Calculate time to afford this upgrade
                        const shortfall = Math.max(0, cost - state.score);
                        const timeToAfford = currentCPS > 0 ? shortfall / currentCPS : Infinity;

                        // Only consider if available within 60 seconds
                        if (timeToAfford > TIME_HORIZON) return;

                        const eff = u.cps / cost;

                        if (eff > maxEff) {
                            maxEff = eff;
                            targetId = u.id;
                        }
                    });

                    // Only buy if we can afford the BEST one (within the 60s window)
                    if (targetId && state.score < getCost(targetId)) {
                        targetId = null; // Wait
                    }
                }

                if (targetId) {
                    buyUpgrade(targetId);

                    // Trigger animation for auto-bought item
                    const element = document.getElementById(`upgrade-${targetId}`);
                    if (element) {
                        element.classList.add('auto-bought');
                        // Remove class after animation completes
                        setTimeout(() => {
                            element.classList.remove('auto-bought');
                        }, 600);
                    }
                }
            }
        }

        // Heat Logic
        function updateHeat() {
            if (state.metaUpgrades.clickFrenzy.count === 0) return;

            const frenzyLevel = state.metaUpgrades.clickFrenzy.count;

            // Decay Rate
            let decay = 1.5; // Base decay
            if (frenzyLevel >= 2) decay = 0.75; // Slower decay

            if (heat > 0) {
                heat = Math.max(0, heat - decay);
                updateHeatVisuals();
            }

            // Level 8: Momentum - Update multiplier based on heat and clicking
            if (frenzyLevel >= 8) {
                updateMomentum();
            }
        }

        function updateHeatVisuals() {
            if (state.metaUpgrades.clickFrenzy.count > 0) {
                heatContainer.style.display = 'block';
                // Scale heat to percentage (150% max = 100% bar width)
                const heatPercent = (heat / 150) * 100;
                heatBar.style.width = `${heatPercent}%`;

                if (heat >= 100) {
                    heatContainer.classList.add('active');
                    const frenzyLevel = state.metaUpgrades.clickFrenzy.count;

                    // Build heat text based on active bonuses
                    let clickMult = (frenzyLevel >= 3) ? "x5" : "x2";
                    let bonusText = `MAX HEAT! (${clickMult} Clicks`;

                    // Level 7: Blazing Strikes
                    if (frenzyLevel >= 7) {
                        bonusText += " +5";
                    }

                    // Add Inferno Mode indicator
                    if (frenzyLevel >= 5) {
                        bonusText += " + 10% CPS";
                    }

                    // Level 8: Momentum - Show multiplier if significant
                    if (frenzyLevel >= 8 && momentumMultiplier > 1.01) {
                        bonusText += ` + ${momentumMultiplier.toFixed(2)}x CPS`;
                    }

                    bonusText += ")";

                    heatText.textContent = bonusText;
                } else {
                    heatContainer.classList.remove('active');
                }

                // Update max CPS display opacity based on heat
                updateMaxCpsDisplay();
            }
        }

        // Click Tracking Functions
        function trackClick() {
            const now = Date.now();
            clickTimestamps.push(now);

            // Remove clicks older than 60 seconds
            const sixtySecondsAgo = now - 60000;
            clickTimestamps = clickTimestamps.filter(timestamp => timestamp > sixtySecondsAgo);

            // Calculate clicks per second over 1-second intervals
            const oneSecondAgo = now - 1000;
            const clicksInLastSecond = clickTimestamps.filter(timestamp => timestamp > oneSecondAgo).length;

            // Update max if current rate is higher
            if (clicksInLastSecond > maxClicksPerSecond) {
                maxClicksPerSecond = clicksInLastSecond;
            }

            // Decay max value if no clicks in last 60 seconds match it
            const maxInWindow = calculateMaxClicksInWindow();
            if (maxInWindow < maxClicksPerSecond) {
                maxClicksPerSecond = maxInWindow;
            }

            updateMaxCpsDisplay();
        }

        function calculateMaxClicksInWindow() {
            if (clickTimestamps.length === 0) return 0;

            let max = 0;
            const now = Date.now();

            // Check each second in the last 60 seconds
            for (let i = 0; i < 60; i++) {
                const secondStart = now - (i * 1000);
                const secondEnd = secondStart - 1000;
                const clicksInSecond = clickTimestamps.filter(t => t <= secondStart && t > secondEnd).length;
                max = Math.max(max, clicksInSecond);
            }

            return max;
        }

        function updateMaxCpsDisplay() {
            if (state.metaUpgrades.clickFrenzy.count > 0) {
                // Check if there are any recent clicks (within last 60 seconds)
                const now = Date.now();
                const sixtySecondsAgo = now - 60000;
                const hasRecentClicks = clickTimestamps.some(t => t > sixtySecondsAgo);

                if (hasRecentClicks) {
                    maxCpsDisplay.style.display = 'block';
                    maxCpsValue.textContent = maxClicksPerSecond;

                    // Opacity based on heat - fade out as heat goes below 50%
                    // At 50% heat (75/150) or above: fully visible (opacity 1.0)
                    // Below 50% heat: fade out linearly to 0
                    const heatPercent = heat / 150; // 0 to 1 (where 1 = 150 heat)
                    const opacity = heatPercent >= 0.5 ? 1.0 : (heatPercent / 0.5);
                    maxCpsDisplay.style.opacity = opacity;
                } else {
                    maxCpsDisplay.style.display = 'none';
                }
            } else {
                maxCpsDisplay.style.display = 'none';
            }
        }

        // Momentum System (Level 8)
        function updateMomentum() {
            // This runs every 100ms (same as heat decay)
            if (heat >= 100) {
                // Build momentum based on current clicking speed
                const now = Date.now();
                const oneSecondAgo = now - 1000;
                const currentClicksPerSecond = clickTimestamps.filter(t => t > oneSecondAgo).length;

                // Gain momentum based on clicking speed
                // Formula: (clicks/sec / 10) * 0.001 per tick (0.01 per second)
                // At 10 clicks/sec: +0.01 per second = +0.6 per minute
                // Cap based on Infernal Momentum upgrade level
                const baseCap = 3.0;
                const infernalLevel = state.metaUpgrades.infernalMomentum.count;
                const momentumCap = baseCap * Math.pow(2, infernalLevel); // 3x, 6x, 12x, 24x, 48x

                let momentumGain = (currentClicksPerSecond / 10) * 0.001;

                // Apply momentum rate multiplier from Click Frenzy levels 9+
                let momentumMultiplierRate = 1;
                if (state.metaUpgrades.clickFrenzy.count >= 9) {
                    momentumMultiplierRate = state.metaUpgrades.clickFrenzy.count - 7; // 2x at level 9, up to 5x at level 12
                }
                momentumGain *= momentumMultiplierRate;

                momentumMultiplier = Math.min(momentumCap, momentumMultiplier + momentumGain);

                // Track time at max heat
                timeAtMaxHeat += 0.1; // 100ms = 0.1 seconds
            } else {
                // Decay momentum when not at max heat
                // Decay faster than it builds
                momentumMultiplier = Math.max(1.0, momentumMultiplier - 0.005);
                timeAtMaxHeat = 0; // Reset timer
            }
        }

        // Golden Cookie Logic
        function trySpawnGoldenCookie() {
            const level = state.metaUpgrades.luckyClover.count;
            if (level === 0) return;

            // Base chance: 1% per second
            // Level 3: Double chance (2%)
            // Level 5: Quadruple chance (4%)
            let chance = 0.01;
            if (level >= 3) chance = 0.02;
            if (level >= 5) chance = 0.04;

            if (Math.random() < chance && !document.querySelector('.golden-cookie')) {
                spawnGoldenCookie();
            }
        }

        function spawnGoldenCookie() {
            const el = document.createElement('div');
            el.className = 'golden-cookie';
            el.textContent = 'üçÄ';
            el.style.left = `${Math.random() * 80 + 10}%`;
            el.style.top = `${Math.random() * 80 + 10}%`;

            el.onclick = (e) => {
                e.stopPropagation();
                const level = state.metaUpgrades.luckyClover.count;
                let reward = 100000;
                if (level >= 2) reward = 200000;
                if (level >= 4) reward = 500000;
                if (level >= 6) reward = 1000000;

                state.score += reward;
                state.stats.totalCookies += reward;
                updateUI();

                spawnFloatingText(e.clientX, e.clientY, `+${formatNumber(reward)}!`);
                el.remove();
            };

            document.body.appendChild(el);

            // Auto-Click Logic (Golden Net)
            const netLevel = state.metaUpgrades.goldenNet.count;
            if (netLevel > 0) {
                let delay = 5000;
                if (netLevel >= 2) delay = 2000;
                if (netLevel >= 3) delay = 100;

                setTimeout(() => {
                    if (el.parentNode) el.click();
                }, delay);
            }

            // Despawn after 15s
            setTimeout(() => {
                if (el.parentNode) el.remove();
            }, 15000);
        }

        // Time Warp Logic
        function checkOfflineEarnings() {
            const level = state.metaUpgrades.timeWarp.count;
            if (level === 0) return;

            const now = Date.now();
            const lastSave = state.stats.lastSaveTime || now;
            const diffMs = now - lastSave;
            const diffHours = diffMs / (1000 * 60 * 60);

            if (diffMs < 60000) return; // Less than 1 min, ignore

            let efficiency = 0.1;
            let maxHours = 1;

            if (level >= 2) { efficiency = 0.25; maxHours = 4; }
            if (level >= 3) { efficiency = 0.50; maxHours = 24; }

            const effectiveHours = Math.min(diffHours, maxHours);
            const cps = getCPS();

            if (cps > 0) {
                const earnings = cps * (effectiveHours * 3600) * efficiency;
                if (earnings > 0) {
                    state.score += earnings;
                    state.stats.totalCookies += earnings;
                    alert(`Welcome back! Time Warp generated ${formatNumber(earnings)} cookies while you were away.`);
                    updateUI();
                }
            }
        }

        // Stats Logic
        let statsChart = null;
        let accuracyChart = null;
        let statsInterval = null;
        let currentChartFilter = 'all';
        let showCookies = true;
        let showCPS = true;
        let showUpgrades = true;

        function recordAnalyticsData() {
            // Only record if we have Analytics Lvl 4 unlocked
            // OR if we want to track history in background (optional, but good for UX)
            // Let's record always so data is there when they buy it.

            const now = Date.now();
            const totalUpgrades = Object.values(state.upgrades).reduce((acc, u) => acc + u.count, 0);

            // Calculate accuracy
            const successfulAutoClicks = totalAutoClicks - totalMissedClicks;
            const accuracy = totalAutoClicks > 0 ? (successfulAutoClicks / totalAutoClicks) * 100 : 100;

            state.stats.history.push({
                timestamp: now,
                cookies: state.score,
                cps: getCPS(),
                upgrades: totalUpgrades,
                accuracy: accuracy,
                totalAutoClicks: totalAutoClicks,
                missedClicks: totalMissedClicks
            });

            // Dynamic History Limit based on Analytics Level
            const analyticsLevel = state.metaUpgrades.analytics.count;
            let maxHistory = 0;
            if (analyticsLevel >= 2) maxHistory = 50;
            if (analyticsLevel >= 3) maxHistory = 100;
            if (analyticsLevel >= 4) maxHistory = 200;
            if (analyticsLevel >= 5) maxHistory = 400;
            if (analyticsLevel >= 6) maxHistory = 800;
            if (analyticsLevel >= 7) maxHistory = 2000;
            if (analyticsLevel >= 8) maxHistory = 5000;

            // Always keep at least a small buffer if they have no analytics yet, 
            // so when they buy level 2 they see something immediately.
            if (maxHistory === 0) maxHistory = 20;

            while (state.stats.history.length > maxHistory) {
                state.stats.history.shift();
            }
        }

        function showStats() {
            updateStatsContent();
            statsModal.classList.add('active');

            // Add filter button listeners
            const filterBtns = document.querySelectorAll('.chart-filter-btn');
            filterBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Remove active from all
                    filterBtns.forEach(b => b.classList.remove('active'));
                    // Add active to clicked
                    e.target.classList.add('active');
                    // Update filter
                    currentChartFilter = e.target.dataset.filter;
                    // Re-render chart
                    renderChart();
                });
            });

            // Set initial active button
            filterBtns.forEach(btn => {
                if (btn.dataset.filter === currentChartFilter) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Series Filters
            const seriesFilters = document.getElementById('seriesFilters');
            seriesFilters.innerHTML = '';
            if (analyticsLevel >= 2) {
                const cookiesBtn = document.createElement('button');
                cookiesBtn.className = 'chart-filter-btn' + (showCookies ? ' active' : '');
                cookiesBtn.dataset.series = 'cookies';
                cookiesBtn.textContent = 'Cookies';
                seriesFilters.appendChild(cookiesBtn);
            }
            if (analyticsLevel >= 3) {
                const cpsBtn = document.createElement('button');
                cpsBtn.className = 'chart-filter-btn' + (showCPS ? ' active' : '');
                cpsBtn.dataset.series = 'cps';
                cpsBtn.textContent = 'CPS';
                seriesFilters.appendChild(cpsBtn);
            }
            if (analyticsLevel >= 6) {
                const upgradesBtn = document.createElement('button');
                upgradesBtn.className = 'chart-filter-btn' + (showUpgrades ? ' active' : '');
                upgradesBtn.dataset.series = 'upgrades';
                upgradesBtn.textContent = 'Upgrades';
                seriesFilters.appendChild(upgradesBtn);
            }

            // Add event listeners for series filters
            const seriesBtns = seriesFilters.querySelectorAll('.chart-filter-btn');
            seriesBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const series = e.target.dataset.series;
                    if (series === 'cookies') showCookies = !showCookies;
                    else if (series === 'cps') showCPS = !showCPS;
                    else if (series === 'upgrades') showUpgrades = !showUpgrades;
                    e.target.classList.toggle('active');
                    renderChart();
                });
            });

            // Live Update Loop
            if (statsInterval) clearInterval(statsInterval);
            statsInterval = setInterval(() => {
                updateStatsContent();
                if (state.metaUpgrades.analytics.count >= 2) {
                    renderChart();
                }
                if (state.metaUpgrades.analytics.count >= 8 && totalMissedClicks > 0) {
                    renderAccuracyChart();
                }
            }, 1000);

            if (state.metaUpgrades.analytics.count >= 2) {
                renderChart();
            }
            if (state.metaUpgrades.analytics.count >= 8 && totalMissedClicks > 0) {
                renderAccuracyChart();
            }
        }

        function updateStatsContent() {
            const timePlayed = ((Date.now() - state.stats.startTime) / 1000 / 60).toFixed(1);
            const analyticsLevel = state.metaUpgrades.analytics.count;

            // Add missed clicks stat if relevant
            let missedClicksRow = '';
            if (state.metaUpgrades.clickFrenzy.count >= 8 && totalMissedClicks > 0) {
                const totalAutoClicks = state.stats.totalClicks;
                const successfulClicks = totalAutoClicks - totalMissedClicks;
                const accuracy = (successfulClicks / totalAutoClicks * 100).toFixed(1);
                missedClicksRow = `
                    <div class="stat-row">
                        <span class="stat-label">Auto-Click Accuracy</span>
                        <span class="stat-value">${accuracy}% (${formatNumber(totalMissedClicks)} misses)</span>
                    </div>
                `;
            }

            // Update Text
            statsText.innerHTML = `
                <div class="stat-row">
                    <span class="stat-label">Total Cookies Earned</span>
                    <span class="stat-value">${formatNumber(state.stats.totalCookies)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Clicks</span>
                    <span class="stat-value">${formatNumber(state.stats.totalClicks)}</span>
                </div>
                ${missedClicksRow}
                <div class="stat-row">
                    <span class="stat-label">Time Played</span>
                    <span class="stat-value">${timePlayed} mins</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Current CPS</span>
                    <span class="stat-value">${formatCPS(getCPS())}</span>
                </div>
            `;

            // Handle Chart Visibility
            if (analyticsLevel >= 2) {
                statsChartContainer.style.display = 'block';
                chartFilters.style.display = 'flex';
                seriesFilters.style.display = 'flex';
            } else {
                statsChartContainer.style.display = 'none';
                chartFilters.style.display = 'none';
                seriesFilters.style.display = 'none';
            }

            // Handle Accuracy Chart Visibility
            const accuracyChartContainer = document.getElementById('accuracyChartContainer');
            if (analyticsLevel >= 8 && totalMissedClicks > 0) {
                accuracyChartContainer.style.display = 'block';
            } else {
                accuracyChartContainer.style.display = 'none';
            }
        }

        function closeStatsModal() {
            statsModal.classList.remove('active');
            if (statsInterval) clearInterval(statsInterval);
        }

        function renderChart() {
            const ctx = document.getElementById('statsChart');
            if (!ctx) return;

            const level = state.metaUpgrades.analytics.count;
            const now = Date.now();
            let filteredHistory = state.stats.history;

            if (currentChartFilter !== 'all') {
                let timeMs;
                switch(currentChartFilter) {
                    case 'day': timeMs = 24 * 60 * 60 * 1000; break;
                    case 'hour': timeMs = 60 * 60 * 1000; break;
                    case '15min': timeMs = 15 * 60 * 1000; break;
                    case '1min': timeMs = 60 * 1000; break;
                }
                filteredHistory = state.stats.history.filter(h => h.timestamp > now - timeMs);
            }

            const labels = filteredHistory.map((h, i) => i);
            const cookiesData = filteredHistory.map(h => h.cookies);
            const cpsData = filteredHistory.map(h => h.cps);
            const upgradesData = filteredHistory.map(h => h.upgrades);

            const datasets = [];

            // Level 2: Cookies
            if (level >= 2 && showCookies) {
                datasets.push({
                    label: 'Cookies',
                    data: cookiesData,
                    borderColor: '#fbbf24',
                    yAxisID: 'y',
                    tension: 0 // Straight lines
                });
            }

            // Level 3: CPS
            if (level >= 3 && showCPS) {
                datasets.push({
                    label: 'CPS',
                    data: cpsData,
                    borderColor: '#a855f7',
                    yAxisID: 'y1',
                    tension: 0 // Straight lines
                });
            }

            // Level 6: Upgrades
            if (level >= 6 && showUpgrades) {
                datasets.push({
                    label: 'Upgrades',
                    data: upgradesData,
                    borderColor: '#3b82f6',
                    yAxisID: 'y1', // Share right axis with CPS
                    borderDash: [5, 5],
                    tension: 0 // Straight lines
                });
            }

            if (statsChart) {
                statsChart.data.labels = labels;
                statsChart.data.datasets = datasets;
                statsChart.update('none'); // Update without animation for performance
            } else {
                statsChart = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        animation: false, // Disable animation for live updates
                        responsive: true,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            x: { display: false },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: { drawOnChartArea: false }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: '#fff' } }
                        }
                    }
                });
            }
        }

        function renderAccuracyChart() {
            const ctx = document.getElementById('accuracyChart');
            if (!ctx) return;

            const now = Date.now();
            let filteredHistory = state.stats.history.filter(h => h.accuracy !== undefined);

            if (currentChartFilter !== 'all') {
                let timeMs;
                switch(currentChartFilter) {
                    case 'day': timeMs = 24 * 60 * 60 * 1000; break;
                    case 'hour': timeMs = 60 * 60 * 1000; break;
                    case '15min': timeMs = 15 * 60 * 1000; break;
                    case '1min': timeMs = 60 * 1000; break;
                }
                filteredHistory = filteredHistory.filter(h => h.timestamp > now - timeMs);
            }

            const labels = filteredHistory.map((h, i) => i);
            const accuracyData = filteredHistory.map(h => h.accuracy);

            const datasets = [{
                label: 'Accuracy %',
                data: accuracyData,
                borderColor: '#10b981',
                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                fill: true,
                tension: 0.3,
                pointRadius: 2,
                pointHoverRadius: 4
            }];

            if (accuracyChart) {
                accuracyChart.data.labels = labels;
                accuracyChart.data.datasets = datasets;
                accuracyChart.update('none');
            } else {
                accuracyChart = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        animation: false,
                        responsive: true,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            x: { display: false },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                min: 0,
                                max: 100,
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: {
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: { color: '#fff' },
                                display: true
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return 'Accuracy: ' + context.parsed.y.toFixed(1) + '%';
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }

        // UI Update
        function updateUI() {
            scoreEl.textContent = formatNumber(state.score);
            cpsEl.textContent = `${formatCPS(getCPS())} CPS`;
            document.title = `${formatNumber(state.score)} Cookies - Cosmic Clicker`;

            updateUpgradeVisuals(); // Check affordability
            updateTechVisuals(); // Check tech affordability/unlocks
            checkNotifications(); // Check for notifications
        }

        function checkNotifications() {
            // Tech Notifications and Visibility
            let techNotification = false;
            let techUnlocked = false;
            Object.values(state.tech).forEach(t => {
                if (!t.purchased) {
                    // Check if unlocked
                    const triggerBuilding = state.upgrades[t.trigger.building];
                    if (triggerBuilding && triggerBuilding.count >= t.trigger.count) {
                        techUnlocked = true;
                        if (state.score >= t.cost) {
                            techNotification = true;
                        }
                    }
                }
            });

            if (techUnlocked) state.settings.techEverUnlocked = true;

            // Show/hide Tech tab based on whether any tech is unlocked
            if (state.settings.techEverUnlocked) {
                tabTech.style.display = 'block';
                if (techNotification) tabTech.classList.add('has-notification');
                else tabTech.classList.remove('has-notification');
            } else {
                tabTech.style.display = 'none';
                tabTech.classList.remove('has-notification');
                // If Tech tab was active, switch to Structures
                if (tabTech.classList.contains('active')) {
                    switchTab('structures');
                }
            }

            // Meta Notifications and Visibility
            let metaNotification = false;
            let metaUnlocked = false;
            let hasMetaPurchased = false;

            Object.values(state.metaUpgrades).forEach(u => {
                if (u.count > 0) {
                    hasMetaPurchased = true;
                }
                const currentLevel = u.count;
                if (currentLevel < u.levels.length) {
                    const cost = u.levels[currentLevel].cost;
                    // Only mark as unlocked if player can afford it or has already purchased meta upgrades
                    if (state.score >= cost || hasMetaPurchased) {
                        metaUnlocked = true;
                    }
                    if (state.score >= cost) {
                        metaNotification = true;
                    }
                }
            });

            if (metaUnlocked) state.settings.metaEverUnlocked = true;

            // Show/hide Meta tab based on whether any meta upgrade is available
            if (state.settings.metaEverUnlocked) {
                tabMeta.style.display = 'block';
                if (metaNotification) tabMeta.classList.add('has-notification');
                else tabMeta.classList.remove('has-notification');
            } else {
                tabMeta.style.display = 'none';
                tabMeta.classList.remove('has-notification');
                // If Meta tab was active, switch to Structures
                if (tabMeta.classList.contains('active')) {
                    switchTab('structures');
                }
            }
        }

        // Floating Text Effect
        function spawnFloatingText(x, y, text, angle, momentumMultiplier) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.textContent = text;
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            document.body.appendChild(el);

            const velocity = 40 * momentumMultiplier; // Velocity increases with momentum
            const tx = Math.cos(angle) * velocity;
            const ty = -Math.sin(angle) * velocity * momentumMultiplier; // Amplified vertical momentum for pillar effect

            const finalScale = 1 + momentumMultiplier * 0.4; // Scale increases faster than momentum

            el.animate([
                { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                { transform: `translate(${tx}px, ${ty}px) scale(${finalScale})`, opacity: 0 }
            ], {
                duration: 1000,
                easing: 'ease-out'
            }).onfinish = () => el.remove();
        }

        // Particle Effect
        function createParticles(x, y, baseAngle, momentumMultiplier) {
            for (let i = 0; i < 6; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                document.body.appendChild(p);

                const size = Math.random() * 8 + 4;
                p.style.width = `${size}px`;
                p.style.height = `${size}px`;
                p.style.left = `${x}px`;
                p.style.top = `${y}px`;

                // Use base angle with small random variation for scattering effect
                const angleVariation = (Math.random() - 0.5) * 0.3; // ¬±0.3 radians (~17¬∞) variation
                const angle = baseAngle + angleVariation;

                const velocity = (Math.random() * 50 + 20) * momentumMultiplier; // Velocity increases with momentum
                const tx = Math.cos(angle) * velocity;
                const ty = -Math.sin(angle) * velocity; // Negative to move upward in screen coordinates

                p.animate([
                    { transform: 'translate(0, 0)', opacity: 1 },
                    { transform: `translate(${tx}px, ${ty}px)`, opacity: 0 }
                ], {
                    duration: 500,
                    easing: 'ease-out'
                }).onfinish = () => p.remove();
            }
        }

        // Game Loop
        let lastTime = performance.now();
        let accumulator = 0;

        function gameLoop(currentTime) {
            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            if (dt > 0) {
                const cps = getCPS();
                if (cps > 0) {
                    // Add fractional cookies
                    const amount = cps * dt;
                    state.score += amount;
                    state.stats.totalCookies += amount;
                    updateUI();
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // Persistence
        function saveGame() {
            if (isResetting) return; // Don't save if resetting
            state.stats.lastSaveTime = Date.now();
            localStorage.setItem('cosmicClickerSave', JSON.stringify(state));
        }

        function loadGame() {
            const saved = localStorage.getItem('cosmicClickerSave');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Merge saved state with default structure to handle version updates
                    state = {
                        ...defaultState,
                        ...parsed,
                        upgrades: { ...defaultState.upgrades },
                        metaUpgrades: { ...defaultState.metaUpgrades },
                        stats: { ...defaultState.stats, ...parsed.stats }
                    };

                    // Migration: autoBuyerEnabled -> autoBuyerMode
                    if (parsed.settings && parsed.settings.autoBuyerEnabled !== undefined) {
                        state.settings.autoBuyerMode = parsed.settings.autoBuyerEnabled ? 'cheapest' : 'off';
                        delete state.settings.autoBuyerEnabled;
                    }
                    if (!state.settings.autoBuyerMode) state.settings.autoBuyerMode = 'off';
                    if (!state.settings.autoClickerMode) state.settings.autoClickerMode = 'on';

                    // Fix: Restore upgrade counts carefully
                    Object.keys(parsed.upgrades).forEach(key => {
                        if (state.upgrades[key]) {
                            state.upgrades[key].count = parsed.upgrades[key].count;
                        }
                    });

                    // Restore Meta Upgrades
                    if (parsed.metaUpgrades) {
                        Object.keys(parsed.metaUpgrades).forEach(key => {
                            if (state.metaUpgrades[key]) {
                                state.metaUpgrades[key].count = parsed.metaUpgrades[key].count;
                            }
                        });
                    }

                    // Start auto clicker if purchased and enabled
                    if (state.metaUpgrades.autoClicker && state.metaUpgrades.autoClicker.count > 0 && state.settings.autoClickerMode === 'on') {
                        const interval = autoClickerIntervals[state.metaUpgrades.autoClicker.count - 1];
                        autoClickerInterval = setInterval(() => {
                            const rect = cookieBtn.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;
                            const radius = rect.width / 2;
                            
                            let offsetX = 0;
                            let offsetY = 0;
                            
                            if (state.metaUpgrades.clickFrenzy.count >= 8 && (heat >= 100 || momentumMultiplier > 1.5)) {
                                const momentumInaccuracy = (momentumMultiplier - 1) * 0.3;
                                const heatInaccuracy = (heat / 150) * 0.2;
                                let inaccuracyFactor = momentumInaccuracy + heatInaccuracy;
                                
                                const precisionLevel = state.metaUpgrades.autoClickPrecision.count;
                                if (precisionLevel >= 1) inaccuracyFactor *= 0.8;
                                if (precisionLevel >= 2) inaccuracyFactor *= 0.75;
                                if (precisionLevel >= 3) inaccuracyFactor *= 0.67;
                                if (precisionLevel >= 4) inaccuracyFactor *= 0.5;
                                if (precisionLevel >= 5 && momentumMultiplier < 50) inaccuracyFactor = 0;
                                if (precisionLevel >= 6 && momentumMultiplier < 100) inaccuracyFactor = 0;
                                if (precisionLevel >= 7 && momentumMultiplier < 200) inaccuracyFactor = 0;
                                if (precisionLevel >= 8 && momentumMultiplier < 400) inaccuracyFactor = 0;
                                if (precisionLevel >= 9) inaccuracyFactor = 0;
                                
                                const maxOffset = radius * inaccuracyFactor;
                                const angle = Math.random() * Math.PI * 2;
                                const distance = Math.random() * maxOffset;
                                offsetX = Math.cos(angle) * distance;
                                offsetY = Math.sin(angle) * distance;
                            }
                            
                            performClick(centerX + offsetX, centerY + offsetY, true);
                        }, interval);
                    }
                } catch (e) {
                    console.error("Save file corrupted", e);
                }
            } else {
                // First time playing - ensure startTime is set to now
                state.stats.startTime = Date.now();
            }
        }

        // Reset


        // Tooltip Logic
        function showTooltip(id, x, y) {
            const u = state.upgrades[id];
            const cost = getCost(id);
            let totalCps = u.cps * u.count;

            // Apply Tech Multipliers for this building
            let multiplier = 1;
            Object.values(state.tech).forEach(t => {
                if (t.purchased && t.effect.type === 'mult' && t.effect.target === u.id) {
                    multiplier *= t.effect.value;
                }
            });
            totalCps *= multiplier;

            // Advanced Analytics
            const analyticsLevel = state.metaUpgrades.analytics.count;
            let extraStats = '';

            if (analyticsLevel >= 2) {
                const efficiency = (u.cps / cost * 1000).toFixed(2); // CPS per 1k cookies
                extraStats += `<div class="tooltip-stat">Eff: <span>${efficiency} CPK</span></div>`;
            }

            if (analyticsLevel >= 3) {
                let timeToWait = "Ready";
                if (state.score < cost) {
                    const cps = getCPS();
                    if (cps > 0) {
                        const seconds = (cost - state.score) / cps;
                        if (seconds < 60) timeToWait = `${seconds.toFixed(0)}s`;
                        else timeToWait = `${(seconds / 60).toFixed(1)}m`;
                    } else {
                        timeToWait = "‚àû";
                    }
                }
                extraStats += `<div class="tooltip-stat">Wait: <span>${timeToWait}</span></div>`;
            }

            tooltip.innerHTML = `
                <div class="tooltip-header">${u.name}</div>
                <div class="tooltip-stat">Cost: <span>üç™ ${formatNumber(cost)}</span></div>
                <div class="tooltip-stat">CPS: <span>${formatCPS(u.cps * multiplier)}</span></div>
                <div class="tooltip-stat">Owned: <span>${u.count}</span></div>
                <div class="tooltip-stat">Total CPS: <span>${formatCPS(totalCps)}</span></div>
                ${extraStats}
            `;

            tooltip.style.display = 'block';
            moveTooltip(x, y);
        }

        function moveTooltip(x, y) {
            // Keep tooltip within bounds
            const width = tooltip.offsetWidth;
            const height = tooltip.offsetHeight;

            let left = x - width - 10;
            let top = y - height / 2;

            if (left < 0) left = x + 20; // Flip to right if too close to left edge
            if (top < 0) top = 10;
            if (top + height > window.innerHeight) top = window.innerHeight - height - 10;

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        // Start
        init();

    </script>
</body>

</html>
